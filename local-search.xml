<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库漫谈</title>
    <link href="/2023/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%BC%AB%E8%B0%88/"/>
    <url>/2023/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%BC%AB%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库漫谈"><a href="#数据库漫谈" class="headerlink" title="数据库漫谈"></a>数据库漫谈</h1><h2 id="常见的关系型数据库和非关系型数据及其区别"><a href="#常见的关系型数据库和非关系型数据及其区别" class="headerlink" title="常见的关系型数据库和非关系型数据及其区别"></a>常见的关系型数据库和非关系型数据及其区别</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织</p><p><strong>优点：</strong></p><ol><li>易于维护：都是使用表结构，格式一致；</li><li>使用方便：SQL语言通用，可用于复杂查询；</li><li>复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</li></ol><p><strong>缺点：</strong></p><ol><li>读写性能比较差，尤其是海量数据的高效率读写；</li><li>固定的表结构，灵活度稍欠；</li><li>高并发读写需求，传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈。</li></ol><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a><strong>非关系型数据库</strong></h3><p>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。</p><p><strong>优点：</strong></p><ol><li>格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。</li><li>速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；</li><li>高扩展性；</li><li>成本低：nosql数据库部署简单，基本都是开源软件。</li></ol><p><strong>缺点：</strong></p><ol><li>不提供sql支持，学习和使用成本较高；</li><li>无事务处理；</li><li>数据结构相对复杂，复杂查询方面稍欠。</li></ol><h3 id="非关系型数据库的分类和比较："><a href="#非关系型数据库的分类和比较：" class="headerlink" title="非关系型数据库的分类和比较："></a>非关系型数据库的分类和比较：</h3><ol><li>文档型</li><li>key-value型(Hive)</li><li>列式数据库</li><li>图形数据库(Neo4j)</li></ol><h2 id="SQL之五种JOIN连接及各类型JOIN解析"><a href="#SQL之五种JOIN连接及各类型JOIN解析" class="headerlink" title="SQL之五种JOIN连接及各类型JOIN解析"></a>SQL之五种JOIN连接及各类型JOIN解析</h2><h3 id="JOIN连接之内连接-INNER-JOIN"><a href="#JOIN连接之内连接-INNER-JOIN" class="headerlink" title="JOIN连接之内连接(INNER JOIN)"></a><strong>JOIN连接之内连接(INNER JOIN)</strong></h3><img src="https://s2.loli.net/2023/04/08/Gr9TKSBVvzqx8fM.png" style="zoom:80%;" /><ul><li>INNER JOIN内连接也叫显性内连接,展示的是两表之间的交集，即获取的是符合查询条件的信息</li><li>隐形内连接：where连接</li></ul><h3 id="JOIN连接之左连接-x2F-左外连接-LEFT-JOIN-x2F-LEFT-OUTER-JOIN"><a href="#JOIN连接之左连接-x2F-左外连接-LEFT-JOIN-x2F-LEFT-OUTER-JOIN" class="headerlink" title="JOIN连接之左连接&#x2F;左外连接(LEFT JOIN&#x2F;LEFT OUTER JOIN)"></a><strong>JOIN连接之左连接&#x2F;左外连接(LEFT JOIN&#x2F;LEFT OUTER JOIN)</strong></h3><img src="https://s2.loli.net/2023/04/08/4ZOPyFW1k8hjVQ7.png" alt="image-20230408164357987" style="zoom:80%;" /><p>左连接是以LEFT JOIN为基准进行查询，左连接查询的就是左表的全部信息和符合查询条件的信息两部分。</p><p>如果左表展示出来的全部信息，右表没有相对应的信息，则右表记录为null。</p><h3 id="JOIN连接之右连接-x2F-右外连接-RIGHT-JOIN-x2F-RIGHT-OUTER-JOIN"><a href="#JOIN连接之右连接-x2F-右外连接-RIGHT-JOIN-x2F-RIGHT-OUTER-JOIN" class="headerlink" title="JOIN连接之右连接&#x2F;右外连接(RIGHT JOIN&#x2F;RIGHT OUTER JOIN)"></a><strong>JOIN连接之右连接&#x2F;右外连接(RIGHT JOIN&#x2F;RIGHT OUTER JOIN)</strong></h3><img src="https://s2.loli.net/2023/04/08/zWknsq5RJ7IXlDj.png" alt="image-20230408164419438" style="zoom:80%;" /><p>右连接与左连接正好相反，以RIGHT JOIN为基准，展示的信息是RIGHT JOIN右边右表的全部信息加上左右两边符合关联查询条件的。 如果右表展示出来的全部信息，左表没有相对应的信息，则左表记录为null。</p><h3 id="JOIN连接之全连接-FULL-JOIN"><a href="#JOIN连接之全连接-FULL-JOIN" class="headerlink" title="JOIN连接之全连接(FULL JOIN)"></a><strong>JOIN连接之全连接(FULL JOIN)</strong></h3><img src="https://s2.loli.net/2023/04/08/7FeB1rECdGUNpSH.png" alt="image-20230408164444018" style="zoom:80%;" /><p>Full outer join展示的是a表和b表的全部信息(a和b的并集)。但需要注意的是，对于没有匹配的记录(即a.id和b.id没有一一对应的)，则会以null作为值。可以使用IFNULL判断。</p><h3 id="JOIN连接之交叉连接-笛卡尔积-CROSS-JOIN"><a href="#JOIN连接之交叉连接-笛卡尔积-CROSS-JOIN" class="headerlink" title="JOIN连接之交叉连接(笛卡尔积)(CROSS JOIN)"></a><strong>JOIN连接之交叉连接(笛卡尔积)(CROSS JOIN)</strong></h3><p>不带where条件子句，它返回的是被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积</p><p>如果带where，返回或显示的是匹配条件成立的行</p><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><h3 id="索引的作用和缺点"><a href="#索引的作用和缺点" class="headerlink" title="索引的作用和缺点"></a>索引的作用和缺点</h3><h4 id="作用：（IO、唯一、分组排序）"><a href="#作用：（IO、唯一、分组排序）" class="headerlink" title="作用：（IO、唯一、分组排序）"></a>作用：（IO、唯一、分组排序）</h4><ol><li>提高数据检索效率，减少IO成本</li><li>通过创建唯一性索引，可以保持数据库表中每一行数据的唯一性</li><li>减少查询中分组和排序的时间</li></ol><h4 id="缺点：（时空占用、增删改）"><a href="#缺点：（时空占用、增删改）" class="headerlink" title="缺点：（时空占用、增删改）"></a>缺点：（时空占用、增删改）</h4><ol><li>创建索引和维护索引要耗费时间，而且时间随着数据量的增加而增大</li><li>索引需要占用物理空间，如果要建立聚簇索引，所需要的空间会更大</li><li>在对表中的数据进行增删改时需要耗费较多的时间，因为索引也要动态地维护</li></ol><h3 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h3><h4 id="应创建索引的场景"><a href="#应创建索引的场景" class="headerlink" title="应创建索引的场景"></a><strong>应创建索引的场景</strong></h4><ol><li>经常<strong>需要搜索</strong>的列上</li><li>作为<strong>主键</strong>的列上</li><li>经常用在<strong>连接</strong>的列上，这些列主要是一些<strong>外键</strong>，可以加快连接的速度</li><li>经常需要<strong>根据范围</strong>进行搜索的列上</li><li>经常需要<strong>分组排序</strong>的列上</li><li>经常使用在<strong>where</strong>子句上面的列上</li></ol><h4 id="不应该创建索引的场景"><a href="#不应该创建索引的场景" class="headerlink" title="不应该创建索引的场景"></a><strong>不应该创建索引的场景</strong></h4><ol><li>查询中<strong>很少用到</strong>的列</li><li>对于那些具有<strong>很少数据值</strong>的列，比如数据表中的<strong>性别列</strong>，bit数据类型的列（就两种值）</li><li>对于那些定义为<strong>text，image</strong>的列，因为这些列的<strong>数据量相当大</strong></li><li>当<strong>对修改性能的要求远远大于搜索性能</strong>时，因为当增加索引时，会提高搜索性能，但是会降低修改性能</li></ol><h3 id="索引的分类与说明"><a href="#索引的分类与说明" class="headerlink" title="索引的分类与说明"></a>索引的分类与说明</h3><p><strong>主键索引</strong> 设定为主键后数据库会<strong>自动</strong>建立索引，innodb为聚簇索引</p><p><strong>单列索引</strong> 一个索引只包含单个列，一个表可以有多个单列索引</p><p><strong>唯一索引</strong> 索引列的值必须唯一，但允许有空值</p><p><strong>复合索引</strong> 一个索引包含多个列，在数据库操作期间，复合索引比单值索引所需要的开销更小（对于相同的多个列建索引） 如果一个表中的数据在查询时有多个字段总是同时出现则这些字段就可以作为复合索引，形成索引覆盖可以提高查询的效率， 复合索引遵从<strong>最左前缀原则</strong></p><p><strong>聚集索引</strong> 指索引项的排序方式和表中数据记录排序方式一致的索引。它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放只能有一种排列方式，所以一个表只能有一个聚集索引。</p><p><strong>非聚集索引</strong></p><p>与聚集索引相反，索引顺序与物理存储顺序不一致。 非聚集索引的使用场合为： 查询所获数据量较少时； 某字段中的数据的唯一性比较高时；</p><p>非聚集索引必须是稠密索引</p><p><strong>稠密索引</strong> 在稠密索引中，文件中的每个搜索码值都对应一个索引值，也就是说，稠密索引为数据记录文件的每一条记录都设一个键-指针对。</p><p><strong>稀疏索引</strong> 在稀疏索引中，只为搜索码的某些值建立索引项，也就是说，稀疏索引为数据记录文件的每个存储块设一个键-指针对，存储块意味着块内存存储单元连续</p><h2 id="数据库的锁"><a href="#数据库的锁" class="headerlink" title="数据库的锁"></a>数据库的锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="按数据操作的类型分类"><a href="#按数据操作的类型分类" class="headerlink" title="按数据操作的类型分类"></a>按数据操作的类型分类</h4><ul><li><strong>读锁</strong>（共享锁，Share Lock）：针对同一份数据，<strong>多个读操作可以同时进行</strong>而不会互相影响。若事务T对数据对象A加上读锁，则事务T只能读A；<strong>其他事务只能再对A加读锁，而不能加写锁，直到事务T释放A上的读锁</strong>。这就保证了其他事务可以读A，但在事务T释放A上的读锁之前不能对A做任何修改。</li><li><strong>写锁</strong>（排它锁，Exclusive Lock）：<strong>写锁只可以加一个</strong>，当前写操作没有完成前，它会阻断其他写锁和读锁。若事务T对数据对象A加上写锁，则<strong>只允许事务T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁</strong>。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在<strong>增删改操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁</strong>。</li></ul><h4 id="按数据操作的颗粒度分类"><a href="#按数据操作的颗粒度分类" class="headerlink" title="按数据操作的颗粒度分类"></a>按数据操作的颗粒度分类</h4><ul><li><strong>表锁</strong>：MySQL中锁定粒度最大的一种锁，表示对当前操作的<strong>整张表</strong>加锁，它实现简单，资源消耗较少。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</li></ul><p>​     特点：表锁<strong>开销小，加锁快，无死锁</strong>，锁定粒度大，<strong>发生锁冲突的概率最高，并发最低</strong></p><ul><li><strong>行锁</strong>：MySQL中锁定粒度最细的一种锁，表示只针对<strong>当前操作的行</strong>进行加锁。行级锁能大大减少数据库操作的冲突。行级锁分为共享锁和排他锁。InnoDB与MyISAM的最大不同有两点：一是<strong>支持事务</strong>;二是<strong>采用了行级锁</strong>。</li></ul><p>​     特点：行锁<strong>开销大，加锁慢；会出现死锁</strong>；锁定粒度最小，<strong>发生锁冲突的概率最低，并发度也最高</strong>。</p><ul><li><strong>页锁</strong>：页锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定<strong>相邻</strong>的一组记录。</li></ul><p>​     特点：开销和加锁时间介于表锁和行锁之间：<strong>会出现死锁</strong>；锁定粒度介于表锁和行锁之间，并发度一般。</p><h3 id="死锁和避免死锁"><a href="#死锁和避免死锁" class="headerlink" title="死锁和避免死锁"></a>死锁和避免死锁</h3><h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h4><ol><li>互斥条件：一个资源只能被一个线程占有，当这个资源被占用后其他线程就只能等待。</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：当一个线程不主动释放资源时，此资源一直被拥有线程占有。</li><li>循环等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li></ol><h4 id="如何解决死锁问题"><a href="#如何解决死锁问题" class="headerlink" title="如何解决死锁问题"></a>如何解决死锁问题</h4><ul><li><strong>预防死锁</strong></li></ul><p>​ <strong>资源一次性分配</strong>：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</p><p>​ <strong>可剥夺资源</strong>：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</p><p>​ <strong>资源有序分配法</strong>：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p><ul><li><strong>避免死锁</strong></li></ul><p>​ 银行家算法</p><ul><li><strong>检测死锁</strong></li></ul><p>​ 首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表。</p><ul><li><strong>解除死锁</strong></li></ul><p>​ 当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p><p>​ <strong>剥夺资源</strong>：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</p><p>​ <strong>撤消进程</strong>：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用、死锁状态消除为止；所谓代价是指优先级、运行代价、重要性和价值等。</p><h4 id="数据库的避免死锁"><a href="#数据库的避免死锁" class="headerlink" title="数据库的避免死锁"></a>数据库的避免死锁</h4><ul><li>通过表级锁来减少死锁产生的概率。对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率</li><li>多个程序尽量约定以相同的顺序访问表。如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁的产生概率。（资源有序分配法）</li><li>同一个事务尽可能做到一次锁定所需要的所有资源，这样可以减少死锁产生概率（资源一次性分配）</li></ul><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p><strong>悲观锁与乐观锁是根据操作时是否锁住资源来判别的</strong>。悲观锁获取到锁时，必须要锁住资源；乐观锁则不会。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁之所以悲观，那是因为它觉得如果不锁住这个资源，别的线程就会来争抢，造成数据结果错误，所以悲观锁为了确保结果的正确性，会在<strong>每次获取并修改数据时，都把数据锁住，让其他线程无法访问该数据</strong>，这样就可以确保数据内容万无一失，从这点看悲观锁特别稳。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p><strong>悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能。</strong></p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁顾名思义，比较乐观。相比于悲观锁，它是<strong>不锁住资源</strong>的，因为它觉得自己在操作资源时并不会有其他线程干扰。因此，为了保障数据的正确性，它在操作之前，会<strong>先判断在自己操作期间，其他线程是否有操作</strong>。如果没有，直接操作；如果有，则根据业务选择报错或者重试。</p><p>乐观锁的这把锁，其实就是依赖的 CAS （compare and swap：比较并交换）算法或版本号机制。所以，<strong>它在操作资源之前并不需要获得锁，直接读取资源到自己的工作内存内操作。</strong></p><p><strong>乐观锁通常多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量</strong></p><img src="https://s2.loli.net/2023/04/08/AkMp4eNcrEwu1Ot.png" alt="image-20230408164519615" style="zoom:70%;" /><h4 id="数据库的乐观锁和悲观锁"><a href="#数据库的乐观锁和悲观锁" class="headerlink" title="数据库的乐观锁和悲观锁"></a>数据库的乐观锁和悲观锁</h4><ul><li><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。</li></ul><p>​     实现方式：使用数据库中的锁机制</p><ul><li><strong>乐观锁</strong>：假设不会发生并发冲突，只在事务提交时检查是否违反数据完整性。乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</li></ul><p>​     实现方式：一般会使用版本号机制或CAS算法实现。</p><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h3><ul><li>在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</li><li>尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。</li></ul><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。</p><h3 id="使用连接（JOIN）来代替子查询-Sub-Queries"><a href="#使用连接（JOIN）来代替子查询-Sub-Queries" class="headerlink" title="使用连接（JOIN）来代替子查询(Sub-Queries)"></a>使用连接（JOIN）来代替子查询(Sub-Queries)</h3><p>连接（JOIN）之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h3 id="使用联合-UNION-来代替手动创建的临时表"><a href="#使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表"></a>使用联合(UNION)来代替手动创建的临时表</h3><p>union可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。</p><h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。</p><p>要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。</p><p>事务以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。（锁库）</p><h3 id="改变锁的粒度"><a href="#改变锁的粒度" class="headerlink" title="改变锁的粒度"></a>改变锁的粒度</h3><p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。</p><p>有些情况下我们可以通过锁表或锁行的方法来获得更好的性能。</p><h3 id="使用外键"><a href="#使用外键" class="headerlink" title="使用外键"></a>使用外键</h3><p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p><h3 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h3><p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。</p><p>一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。</p><h3 id="优化查询语句"><a href="#优化查询语句" class="headerlink" title="优化查询语句"></a>优化查询语句</h3><ul><li>最好是在相同类型的字段间进行比较的操作</li><li>在建有索引的字段上尽量不要使用函数进行操作。</li><li>应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。</li></ul><h3 id="为数据库分配更多内存"><a href="#为数据库分配更多内存" class="headerlink" title="为数据库分配更多内存"></a>为数据库分配更多内存</h3><p>数据库一般部署在云服务器上，为数据库分配更大内存应对较大数据操作量的场景</p><h3 id="文件格式优化（分布式数据库）"><a href="#文件格式优化（分布式数据库）" class="headerlink" title="文件格式优化（分布式数据库）"></a>文件格式优化（分布式数据库）</h3><p>如：Hive的⽂件存储格式包括以下⼏类：TEXTFILE、SEQUENCEFILE、RCFILE、ORCFILE。其中TEXTFILE为默认格式，建表时不指定则默认为这个格式，导⼊数据时会直接把数据⽂件拷⻉到hdfs（Haddop文件系统）上不进⾏处理。部分较⼤数据源的存储格式可以由TEXTFILE变为ORCFILE。</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>数据仓库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云平台与微服务架构</title>
    <link href="/2023/04/04/%E4%BA%91%E5%B9%B3%E5%8F%B0%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/04/04/%E4%BA%91%E5%B9%B3%E5%8F%B0%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="云平台与微服务架构"><a href="#云平台与微服务架构" class="headerlink" title="云平台与微服务架构"></a>云平台与微服务架构</h1><h2 id="云平台"><a href="#云平台" class="headerlink" title="云平台"></a>云平台</h2><h3 id="对云计算的理解"><a href="#对云计算的理解" class="headerlink" title="对云计算的理解"></a>对云计算的理解</h3><p>云计算通俗点讲就是把以前需要本地处理器计算的任务交到了远程服务器上去做。</p><p>例如你现在要计算出明天的天气预报，所有数据都准备好了，你用自己家的电脑计算，发现自己的电脑计算能力太差，想算出明天的天气预报得1年，那这样就不好了，计算也没价值了。</p><p>但是你又不能专门为计算明天的天气预报去买一台强力服务器去计算，为了降低成本，你就要去使用云计算了，你只需要把计算天气的公式和数据发送到云服务器上，云服务器的计算能力比你的个人家用电脑强了几千倍(因为云服务器是一个服务器群,由很多计算能力强大的服务器组成的)，二十分钟就算好了明天的天气预报，并且把结果给你返回到你的电脑上了，你只需要按照计算的次数或者是服务器的资源使用的多少去支付你需要支付的费用，肯定比你买服务器合适多了。</p><p>以前需要自己来打井解决吃水问题，现在可以由自来水公司统一提供，现在云计算的云端相当于自来水公司，只不过它不是解决水资源供给问题，而是解决了<strong>计算资源</strong>和<strong>存储资源</strong>的<strong>统一、按需、可伸缩</strong>的供给。</p><p>一个机房<strong>空闲的资源</strong>出租给他人使用，使得他人可以在短期具备<strong>同时使用多个计算机用于同一任务</strong>的可能性，同时还具有更好的性价比。就相当于，平常自己买电脑等于是淘宝，云计算是可以五天无理由的团购。</p><p>原来是把一个任务交给一台电脑来完成，小任务用小电脑，大任务就得换大电脑。</p><p>现在是把一个任务交给一堆电脑一起来完成，这堆电脑加起来工作得就像一个超级大的电脑一样。<strong>如果把每一台电脑比作一滴水，那么一起工作的一堆电脑就像是一片云。</strong>如何让一堆电脑工作得像一台大电脑一样，而且能按需要随时添加新电脑进去来改变大电脑的能力，这就是云计算需要解决的问题。</p><p>可以把计算扩充一下。比如说存储。假设很多人想要不定时地看同一部视频。正常来说，都要保存在每个人本地的硬盘上，才能满足每个人不定时的观看。如果借助网络，只要保存在一个服务器上，有人想要看去下载即可，就是共享存储。</p><p>再把云的概念扩展一点，比如生活中的交通。很多人想要从A到B地，每个人如果都需要单独坐小汽车去的话，资源就很浪费，如果共享一辆汽车，就是云交通，资源就会节省很多。云计算的狭义个人理解是指计算能力的共享，通过第三方，使得计算能力统一放在一个地方。</p><h3 id="云计算概念"><a href="#云计算概念" class="headerlink" title="云计算概念"></a>云计算概念</h3><p>云计算是通过 Internet <strong>云服务平台</strong>按需提供<strong>计算</strong>能力、数据库<strong>存储</strong>、<strong>应用</strong>程序和其他 IT 资源，采用<strong>按需支付（使用量）</strong>定价模式。</p><h3 id="云平台概念"><a href="#云平台概念" class="headerlink" title="云平台概念"></a>云平台概念</h3><p>云计算平台也称为云平台，是指基于硬件资源和软件资源的服务，提供计算、网络和存储能力。云平台可以集中对存储、处理、传输等各个环节进行处理，而且速度非常快，调用云服务等资源也更加方便快捷。就拿百度云来说吧，用户可以将相关的信息存储到云平台当中，不管是传输还是处理，都可以通过平台来搞定，还可以通过平台来调用云服务，享受到更便捷的扩展性服务。</p><p>云平台，简单来理解的话就是提供数据、存储数据的一个空间，这个空间非常大，而且它的存储量也是非常大，另外，它还必须具备非常快的运转速度。像百度云是以数据存储为主的云平台，而阿里云是提供弹性计算及信息存储等基础设施服务的云平台。</p><p>云计算平台可以划分为3类：</p><ul><li><p>以数据存储为主的存储型云平台</p></li><li><p>以数据处理为主的计算型云平台</p></li><li><p>计算和数据存储处理兼顾的综合云计算平台</p></li></ul><h3 id="云平台的优势"><a href="#云平台的优势" class="headerlink" title="云平台的优势"></a>云平台的优势</h3><ul><li><strong>稳定性相对很好</strong></li></ul><p>​云平台的应用影响着网站的使用，所以云平台的稳定性对于网站来说很重要。我们平时常见的虚拟主机都是多个网站共享一台主机，如果其中的一个网站受到攻击，那么就会影响到其他的网站，这样空间的稳定性就会大大降低。</p><ul><li><strong>更安全可靠</strong></li></ul><p>​服务器的安全对于用户来说是非常重要的，因为一旦服务器出现故障，网站就不能进行正常的运营，给企业带来的损失将会是不可估量的，所以用户最害怕服务器出现故障。但是云平台一般不会出现这种情况的，就算是网站的运营出现了问题，云平台也会自动转移到其他的机器上。</p><ul><li><strong>无限的容量</strong></li></ul><p>​云平台是全网服务，几乎综合了全球终端的“云”提供的容量，不再局限于一台或者几台服务器之间，所以在某种程度上可以说云计算的存贮是永无止境的。</p><ul><li><strong>具有扩展性</strong></li></ul><p>​对于一些中小型的企业来说，随着业务的不断扩大，可能后期需要对服务器进行扩容和升级等操作。而云平台具有一定的扩展性，可以满足企业的后期扩张升级，在后期就不需要对软硬件进行相应的升级操作。</p><ul><li><strong>存储更方便</strong></li></ul><p>​数据是一个企业的核心内容，所以平时一定要对数据做好备份工作。云平台有一个数据备份功能，就算是硬件出现了问题，数据也不会受到影响或者是出现丢失的情况。只需要后期的正常维护和运维就行了，而且这个是服务商在维护的，可以为企业节省很多的人力。</p><ul><li><strong>更容易的协作与共享</strong></li></ul><p>​极高的速度与无限的容量使异国异地的企业开展协作经营成为可能，在云计算平台下的不同企业可以实现线上办公、同步作业，一个企业发出的最新数据可使“云”的其他企业同步看到并采用，由此实现了资源共享。</p><ul><li><strong>高速</strong></li></ul><p>​相较于任何一个独自存在的企业数据中心，足以覆盖全球的云计算所提供的高速运算和同步服务是这些独力支援的企业所无法比拟的。</p><h3 id="云平台架构"><a href="#云平台架构" class="headerlink" title="云平台架构"></a>云平台架构</h3><p><strong>资源层或基础设施层（IaaS, Infrastructure as a Service）</strong></p><p>由服务器集群组成。传统服务器要想提供高质量服务，需要性能特别好的服务器（内存高，CPU快，磁盘空间大等），价格昂贵。而服务器集群可以使用以前性能不太好的服务器，利用分布式处理技术，依然可以提供可靠服务，节省费用。</p><p>例：Oracle、VMware、阿里云</p><p><strong>虚拟机层</strong></p><p>有了物理机集群后，我们需要在物理机上建立虚拟机。建立虚拟机的目的是为了<strong>最小化资源成本</strong>（最大化资源利用率）。试想一下某台物理机有128G内存，当某段时间连续有小任务量的应用需要处理时，物理机的内存利用率会很低，所以为最大化资源利用率，可以在物理机上独立开辟几个虚拟机，每台虚拟机相当于一个小型服务器，依然可以处理应用请求。</p><p><strong>中间件层或平台层（PaaS, Platform as a Service)</strong></p><p>是云平台的核心层，主要功能为：对虚拟机池资源状态进行监测、预警、优化决策。</p><ul><li><strong>资源监测</strong>：实时监测当前各台虚拟机CPU、内存等使用情况，当然也监测用户应用请求，以便根据应用规模大小进行决策。</li><li><strong>预警</strong>：防患于未然，根据当前虚拟机资源使用情况预测下一秒用户请求量，以便做出相应资源调整，防止宕机。比如CPU使用率上限为70%，所以当预测下一秒达到该触发点时，应有相应响应。</li><li><strong>优化决策</strong>：预警之后，虚拟机要进行资源调度(迁移或伸缩)，采用何种调度策略，才能保证服务和资源利用率是研究重点。由于该层需要对应用进行响应处理，所以需要在虚拟机上搭建操作系统，文件存储系统，以及服务器，当然还有负载均衡系统，如，Nginx（engine x），其实现中间件层功能，相当于网络中的路由器不处理数据，只进行数据转发，数据处理交由虚拟机上的tomcat服务器执行。</li></ul><p>例：新浪SAE、谷歌GAE(Google app engine)、百度云开发引擎</p><p><strong>应用层或软件服务层（SaaS，Software as a Service）</strong></p><p>给用户提供可视化界面。</p><p>应用若为存储：如百度云会给用户提供交互界面，建立文件夹，进行数据存储，在线播放视频等界面，供用户选择操作。</p><p>应用若为租用服务器：界面应该有租用的服务器资源状态。</p><p>例：微软Office、谷歌Apps</p><h3 id="云计算中弹性与可扩展性的区别"><a href="#云计算中弹性与可扩展性的区别" class="headerlink" title="云计算中弹性与可扩展性的区别"></a>云计算中弹性与可扩展性的区别</h3><p>可扩展性：只要相应增加资源容量，就可以处理增加的工作负载。</p><p>弹性：强调启用和停用庞大的资源容量这一概念。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><p>微服务架构是一种架构模式或者说是一种架构风格，它提倡将<strong>单一应用程序</strong>划分成<strong>一组小的服务</strong>，每个服务运行在<strong>自己的独立进程</strong>中，服务之间互相协调、互相配合，为用户提供最终价值。 服务之间采用<strong>轻量级</strong>的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且<strong>能够被独立地部署</strong>到生产环境、类生产环境等。可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p><p>主要思想：去耦合</p><p>在 intellij idea 工具里面就是用 maven 开发的一个个独立的 module，具体就是使用 springboot 开发的一个小的模块，处理单一专业的业务逻辑，一个模块只做一个事情。</p><h3 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h3><p><strong>优点：</strong></p><ul><li>独立开发</li><li>独立部署</li><li>故障隔离：系统一项服务不起作用，不会影响系统运行</li><li>混合技术堆栈：可以使用不同语言技术构建同一应用程序的不同服务</li><li>团队规模降低</li></ul><p><strong>缺点：</strong></p><ul><li>开发人员要处理分布式系统的复杂性</li><li>多服务运维难度：随着服务的增加，运维的压力也在增大</li><li>系统部署依赖</li><li>服务间通信成本</li><li>数据一致性</li><li>系统集成测试</li><li>性能监控</li></ul><h3 id="微服务之间的独立通讯"><a href="#微服务之间的独立通讯" class="headerlink" title="微服务之间的独立通讯"></a>微服务之间的独立通讯</h3><h4 id="远程过程调用（同步通信）"><a href="#远程过程调用（同步通信）" class="headerlink" title="远程过程调用（同步通信）"></a>远程过程调用（同步通信）</h4><p>直接通过远程过程调用来访问别的service。</p><p>示例：dubbo 通过 RPC 远程过程调用、springcloud 通过 REST 接口 json 调用 </p><p>优点：简单，常见。因为没有中间件代理，系统更简单</p><p>缺点：只支持请求&#x2F;响应的模式，不支持别的，比如通知、请求&#x2F;异步响应、发布&#x2F;订阅、发布&#x2F;异步响应，降低了可用性，因为客户端和服务端在请求过程中必须都是可用的</p><h4 id="消息队列（异步通信）"><a href="#消息队列（异步通信）" class="headerlink" title="消息队列（异步通信）"></a>消息队列（异步通信）</h4><p>使用异步消息来做服务间通信。服务间通过消息管道来交换消息，从而通信。</p><p>示例：Kafka、RabbitMQ、ActiveMQ</p><p>优点:把客户端和服务端解耦，更松耦合 提高可用性，因为消息中间件缓存了消息，直到消费者可以消费，支持很多通信机制比如通知、请求&#x2F;异步响应、发布&#x2F;订阅、发布&#x2F;异步响应</p><p>缺点:消息中间件有额外的复杂性</p><h3 id="分布式系统面临的问题"><a href="#分布式系统面临的问题" class="headerlink" title="分布式系统面临的问题"></a>分布式系统面临的问题</h3><p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</p><p><strong>服务雪崩</strong></p><p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.</p><p><strong>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。</strong>比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p><h3 id="服务依赖保护的解决方案："><a href="#服务依赖保护的解决方案：" class="headerlink" title="服务依赖保护的解决方案："></a>服务依赖保护的解决方案：</h3><p>① <strong>熔断模式：</strong>这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</p><p>② <strong>隔离模式：</strong>这种模式就像对系统请求按类型划分成一个个小岛的一样，当某个小岛被火少光了，不会影响到其他的小岛。例如可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。这种模式使用场景非常多，例如将一个服务拆开，对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。</p><p>③ <strong>限流模式：</strong>上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。</p><h3 id="什么是服务熔断，什么是服务降级"><a href="#什么是服务熔断，什么是服务降级" class="headerlink" title="什么是服务熔断，什么是服务降级"></a>什么是服务熔断，什么是服务降级</h3><p><strong>服务熔断</strong></p><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。</p><p>当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。</p><p><strong>Hystrix服务降级</strong></p><p>其实就是线程池中单个线程故障处理，防止单个线程请求时间太长，导致资源长期被占有而得不到释放，从而导致线程池被快速占用完，导致服务崩溃。</p><p><strong>Hystrix能解决如下问题：</strong></p><p>① 请求超时降级，线程资源不足降级，降级之后可以返回自定义数据</p><p>② 线程池隔离降级，分布式服务可以针对不同的服务使用不同的线程池，从而互不影响</p><p>③ 自动触发降级与恢复</p><p>④ 实现请求缓存和请求合并</p><h3 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h3><p><strong>服务开发</strong></p><p>Springboot、Spring、SpringMVC</p><p><strong>服务配置与管理</strong></p><p>Netflix公司的Archaius、阿里的Diamond等</p><p><strong>服务注册与发现</strong></p><p>Eureka、Consul、Zookeeper等</p><p><strong>服务调用</strong></p><p>Rest、RPC、gRPC</p><p><strong>服务熔断器</strong></p><p>Hystrix、Envoy等</p><p><strong>负载均衡</strong></p><p>Ribbon、Nginx等</p><p><strong>服务接口调用(客户端调用服务的简化工具)</strong></p><p>Feign等</p><p><strong>消息队列</strong></p><p>Kafka、RabbitMQ、ActiveMQ等</p><p><strong>服务配置中心管理</strong></p><p>SpringCloudConfig、Chef等</p><p><strong>服务路由（API网关）</strong></p><p>Zuul等</p><p><strong>服务监控</strong></p><p>Zabbix、Nagios、Metrics、Spectator等</p><p><strong>全链路追踪</strong></p><p>Zipkin，Brave、Dapper等</p><p><strong>服务部署</strong></p><p>Docker、OpenStack、Kubernetes等</p><p><strong>数据流操作开发包</strong></p><p>SpringCloud Stream（封装与Redis,Rabbit、Kafka等发送接收消息）</p><p><strong>事件消息总线</strong></p><p>Spring Cloud Bus</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
      <tag>云平台</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据预处理与K-means聚类实现</title>
    <link href="/2023/03/23/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-hw1/"/>
    <url>/2023/03/23/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-hw1/</url>
    
    <content type="html"><![CDATA[<h1 id="Report-hw1-Data-Analysis-and-Mining"><a href="#Report-hw1-Data-Analysis-and-Mining" class="headerlink" title="Report-hw1-Data Analysis and Mining"></a>Report-hw1-Data Analysis and Mining</h1><h2 id="Task-1-Data-pre-processing"><a href="#Task-1-Data-pre-processing" class="headerlink" title="Task 1 Data pre-processing"></a><strong>Task 1 Data pre-processing</strong></h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ul><li>数据集来源：<a href="https://www.kaggle.com/datasets/janiobachmann/bank-marketing-dataset">Bank Marketing Dataset</a></li><li>数据集描述：这个数据集描述了某银行进行的最后一次营销活动，从而帮助该银行找到改进下一次营销活动的最佳策略，并确定有助于制定未来战略的模式。</li><li>数据集特征：<ul><li><p>该数据集共有17列，11162行，各列属性含义如下所示：</p></li><li><p>age 年龄</p></li><li><p>job 职业(admin,unemployed,student,retired,self-employed,housemaid,services,bluecollar,technician,management,entrepreneur,unknown)</p></li><li><p>marital 婚姻状况(single,married,divorced)</p></li><li><p>education 受教育水平(primary,secondary,tertiary,tertiary)</p></li><li><p>default 是否有违约记录(yes,no)</p></li><li><p>balance 账户平均余额</p></li><li><p>housing 住房贷款</p></li><li><p>loan 个人贷款</p></li><li><p>contact 与客户联系沟通方式(cellular,telephone,unknown)</p></li><li><p>day 最后一次联系的时间</p></li><li><p>month 最后一次联系的月份</p></li><li><p>duration 最后一次联系的交流时长</p></li><li><p>campaign 与客户交流的次数</p></li><li><p>pdays 最后一次联系客户过去多久</p></li><li><p>previos 与客户交流次数</p></li><li><p>poutcome 上一次活动的结果(success,failure,unknown)</p></li><li><p>deposit 是否有定期存款(yes,no)</p></li></ul></li></ul><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>原数据集已被清洗的较为完整，所以该作业中人为添加了一些“脏数据”，包括缺失值，异常值等，如下图所示：</p><p>缺失值：</p><img src="https://moe.photo/images/2023/04/08/1.png" alt="img" style="zoom:80%;" /><p>异常值：</p><img src="https://moe.photo/images/2023/04/08/2.png" alt="img" style="zoom:80%;" /><img src="https://moe.photo/images/2023/04/08/3.png" alt="img" style="zoom:80%;" /><img src="https://moe.photo/images/2023/04/08/4.png" alt="img" style="zoom:80%;" /><h4 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h4><img src="https://moe.photo/images/2023/04/08/5.png" alt="img" style="zoom:80%;" /><ol><li>首先，我们认为age也就是年龄的正常范围应该在1-100，所以先将这些正常范围的age筛出</li><li>对筛出来的age取均值（b.mean()）</li><li>遍历数据集，将越界的age改为均值</li><li>接下来处理balance列的异常值，由于之前把几个原本的数据改为了字符串，导致了全列数据被类型转换为了字符串，所以检测异常值只需要看每个数据第一位是否是数字即可，若是，则填充为int值0，若不是，则类型转换为int</li></ol><h4 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h4><img src="https://moe.photo/images/2023/04/08/6.png" alt="img" style="zoom:80%;" /><p>缺失值处理较为简单，采用均值填充法，直接用fillna方法将均值填充进去即可</p><h4 id="数据过滤和选择"><a href="#数据过滤和选择" class="headerlink" title="数据过滤和选择"></a>数据过滤和选择</h4><img src="https://moe.photo/images/2023/04/08/7.png" alt="img" style="zoom:80%;" /><img src="https://moe.photo/images/2023/04/08/8.png" alt="img" style="zoom:80%;" /><p>由于聚类目的是确定优先联系进行营销的客户组别，所以我们只需要那些非管理人员（客户）、有存款、没有负债的数据，基于此，我们进行数据过滤操作；除此之外，我们只需要选择比较核心的数据特征进行聚类即可，一方面便于标准化，另一方面其余列属性的值种类太少，不便于聚类</p><h4 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h4><img src="https://moe.photo/images/2023/04/08/9.png" alt="img" style="zoom:80%;" /><p>数据标准化操作是将数据按比例缩放，使之落入一个小的特定区间。其中最典型的就是数据的归一化处理，即将数据统一映射到[0,1]区间上。</p><p>这里选用的标准化方法是<strong>z-score</strong>标准化，这种方法给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合标准正态分布，即均值为0，标准差为1，其转化函数为：</p><p>x* &#x3D; (x - μ ) &#x2F; σ</p><p>其中μ为所有样本数据的均值，σ为所有样本数据的标准差。标准化后的变量值围绕0上下波动，大于0说明高于平均水平，小于0说明低于平均水平。</p><p>这里我们将数据类型为字符串的poutcome和job两列数据转化为数字索引，便于标准化。</p><p>本作业中处理后的数据形式如下所示：</p><img src="https://moe.photo/images/2023/04/08/10.png" alt="img" style="zoom:80%;" /><h2 id="Task-2-Clustering-algorithms"><a href="#Task-2-Clustering-algorithms" class="headerlink" title="Task 2 Clustering algorithms"></a><strong>Task 2</strong> <strong>Clustering</strong> <strong>algorithms</strong></h2><h3 id="Kmeans聚类算法的实现"><a href="#Kmeans聚类算法的实现" class="headerlink" title="Kmeans聚类算法的实现"></a>Kmeans聚类算法的实现</h3><p>实现流程如下：</p><ol><li>在数据集中随机选取k个数据，作为初始质心；</li></ol><img src="https://moe.photo/images/2023/04/08/11.png" alt="img" style="zoom:80%;" /><ol start="2"><li>计算数据集中每个样本到每个质心的距离，把样本划分到距离最小的质心所属的类别；</li></ol><p>​计算欧氏距离的函数：即x1与x2平方和的平方根</p><img src="https://moe.photo/images/2023/04/08/12.png" alt="img" style="zoom:80%;" /><p>​计算每个样本到质心的距离，并把样本划分到距离最小的质心所属的类别：这里采用字典作为数据结构，通过键值对的形式为样本划类</p><img src="https://moe.photo/images/2023/04/08/13.png" alt="img" style="zoom:80%;" /><ol start="3"><li>根据聚类结果，重新计算质心，当本次计算的质心与上一次质心完全一样（或者收敛）时，停止迭代；</li></ol><p>​否则更新质心，继续执行步骤1、2、3。</p><img src="https://moe.photo/images/2023/04/08/14.png" alt="img" style="zoom:80%;" /><ol start="4"><li>最后产生聚类结果y_preds:</li></ol><img src="https://moe.photo/images/2023/04/08/15.png" alt="img" style="zoom:80%;" /><h3 id="算法实现的困难"><a href="#算法实现的困难" class="headerlink" title="算法实现的困难"></a>算法实现的困难</h3><ol><li>K值的选取不好把握</li><li>采用迭代方法，得到的结果只是局部最优。</li><li>把样本划分到距离最小的质心所属的类别这一步的数据结构选取上遇到了困难，一开始没有想到用字典来实现</li><li>停止迭代的标志一开始难以确定</li></ol><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><h4 id="Kmeans-优化："><a href="#Kmeans-优化：" class="headerlink" title="Kmeans++优化："></a>Kmeans++优化：</h4><p>经过实验，发现Kmeans跑出来的聚类结果不稳定，原因是它随机选取k个数据，导致结果无法收敛。</p><p>因为随机选取，可能会使选取的几个数据点都非常靠近，不仅导致算法收敛很慢，还会导致结果只收敛到局部最小值。</p><p>所以我们使用Kmeans++的方法初始化质心进行优化，其实现流程如下：</p><ol><li>从输入的数据点集合中随机选择一个点作为第一个聚类中心；</li></ol><img src="https://moe.photo/images/2023/04/08/16.png" alt="img" style="zoom:80%;" /><ol start="2"><li>对于数据集中的每一个点xi，计算它与已选择的聚类中心中最近聚类中心的距离D(x)；</li></ol><img src="https://s2.loli.net/2023/04/08/qYe5AdtjL1aWCZl.png" alt="42245b50-f3fb-4b8d-ba70-d1071e7bc6d4" style="zoom:80%;" /><ol start="3"><li>选择一个新的数据点作为新的聚类中心，选择的原则是：D(x)较大的点，被选取作为聚类中心的概率较大；</li></ol><img src="https://s2.loli.net/2023/04/08/z8cKdkAqC4QanNO.png" style="zoom:80%;" /><ol start="4"><li>重复2和3直到选择出k个聚类质心；</li></ol><img src="https://s2.loli.net/2023/04/08/59FJ28NIXMkcmvx.png" alt="2" style="zoom:80%;" /><ol start="5"><li>利用这k个质心来作为初始化质心去运行标准的K-Means算法；</li></ol><h4 id="n-init二次优化"><a href="#n-init二次优化" class="headerlink" title="n_init二次优化:"></a>n_init二次优化:</h4><p>该优化即算法执行n_init次，最终结果取最优的一次（所有样本点到所属的聚类质心的距离之和最小，即为最优）</p><p>数学表现如下：</p><img src="https://s2.loli.net/2023/04/08/6lgpvwCBmDL5uAF.png" style="zoom:80%;" /><p>在Kmeans++方法选取质心的基础上，再添加参数n_init来优化聚类的准确性和稳定性，为此我们定义函数select_optimal：</p><img src="https://s2.loli.net/2023/04/08/I5xHO9qNWrU8A2o.png" alt="5" style="zoom:80%;" /><p>该函数找到n_init次运行中，J最小时，对应的聚类质心，即为最优解。</p><h4 id="k值选取方法优化："><a href="#k值选取方法优化：" class="headerlink" title="k值选取方法优化："></a>k值选取方法优化：</h4><p>传统的k值选取方法使用肘部图法，我们这里采用从簇内的稠密程度和簇间的离散程度来评估聚类的效果。常见的</p><p>方法有轮廓系数Silhouette Coefficient和Calinski-Harabasz Index。</p><p>这里我们使用sklearn中已封装好的sklearn.metrics.calinski_harabasz_score方法来选取k值</p><p>它的得分越高，聚类效果越好，得分最高时，就是最佳的k值。</p><p>具体过程如下：</p><p>k&#x3D;5：</p><img src="https://s2.loli.net/2023/04/08/HVTQZIGzicOPU8X.jpg" style="zoom:80%;" /><p>k&#x3D;6：</p><img src="https://s2.loli.net/2023/04/08/LzxTF7wZobyU4kc.jpg" style="zoom:80%;" /><p>k&#x3D;7：</p><img src="https://s2.loli.net/2023/04/08/R94HVUFAB6lNSIy.jpg" style="zoom:80%;" /><p>可以看到，K&#x3D;6的时候，得分最高，6就是我们要找的k值。</p><h3 id="实验结果及比较分析"><a href="#实验结果及比较分析" class="headerlink" title="实验结果及比较分析"></a>实验结果及比较分析</h3><h4 id="结果展现绘图"><a href="#结果展现绘图" class="headerlink" title="结果展现绘图"></a>结果展现绘图</h4><p>结果展现形式：散点图</p><p>由于我们的数据是6维的，要绘制散点图需要进行降维，这里我们采用PCA法（主成分分析）降到二维：</p><img src="https://s2.loli.net/2023/04/08/mtLNHZTYIfuwlyM.png" style="zoom:80%;" /><h4 id="传统Kmeans聚类结果"><a href="#传统Kmeans聚类结果" class="headerlink" title="传统Kmeans聚类结果"></a>传统Kmeans聚类结果</h4><p>在自主实现的Kmeans类中，我们指定init参数为random即可实现传统Kmeans聚类</p><p>第一次聚类：</p><img src="https://s2.loli.net/2023/04/08/sRvFGAw7lgih3BY.png" alt="image-20230408163734866" style="zoom:80%;" /><p>第二次聚类：</p><img src="https://s2.loli.net/2023/04/08/n9DpaW7UcJyLIBM.png" alt="image-20230408163815155" style="zoom:80%;" /><p>第三次聚类</p><img src="https://s2.loli.net/2023/04/08/uaEcXNw7syzrRx6.png" alt="image-20230408163848246" style="zoom:80%;" /><p>从calinski_harabasz_score得分和散点图可以看出，每次聚类的效果都不一致，这说明传统Kmeans的聚类很不稳定</p><h4 id="优化算法聚类结果"><a href="#优化算法聚类结果" class="headerlink" title="优化算法聚类结果"></a>优化算法聚类结果</h4><p>在自主实现的Kmeans类中，我们指定init参数为Kmeans++即可实现传统Kmenas聚类</p><p>第一次聚类：</p><img src="https://s2.loli.net/2023/04/08/MTvXxlkH6esuS3I.png" alt="image-20230408163924359" style="zoom:80%;" /><p>第二次聚类</p><img src="https://s2.loli.net/2023/04/08/1p4F6mtRToNlPMK.png" alt="image-20230408163951245" style="zoom:80%;" /><p>第三次聚类</p><img src="https://s2.loli.net/2023/04/08/Q9dGwRYAZ7kDuqx.png" alt="image-20230408164013129" style="zoom:80%;" /><p>不难看出，相比于传统Kmeans方法，我们的优化算法聚类效果稳定的多，且从calinski_harabasz_score得分可以看出，优化算法的平均聚类效果更好。</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据挖掘</tag>
      
      <tag>聚类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软工题解</title>
    <link href="/2023/03/06/%E8%BD%AF%E5%B7%A5%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/03/06/%E8%BD%AF%E5%B7%A5%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="软工题解"><a href="#软工题解" class="headerlink" title="软工题解"></a>软工题解</h1><h2 id="注：括号后的⭐️表示复习优先级，越多表示优先级越高（⭐️⭐️⭐️最高，⭐️最低）"><a href="#注：括号后的⭐️表示复习优先级，越多表示优先级越高（⭐️⭐️⭐️最高，⭐️最低）" class="headerlink" title="注：括号后的⭐️表示复习优先级，越多表示优先级越高（⭐️⭐️⭐️最高，⭐️最低）"></a>注：括号后的⭐️表示复习优先级，越多表示优先级越高（⭐️⭐️⭐️最高，⭐️最低）</h2><h2 id="Chapter-1-软件的本质-The-Nature-of-Software"><a href="#Chapter-1-软件的本质-The-Nature-of-Software" class="headerlink" title="Chapter 1 软件的本质 The Nature of Software"></a><strong>Chapter 1</strong> 软件的本质 The Nature of Software</h2><h3 id="1-软件是什么：（⭐️⭐️）"><a href="#1-软件是什么：（⭐️⭐️）" class="headerlink" title="1. 软件是什么：（⭐️⭐️）"></a>1. 软件是什么：（⭐️⭐️）</h3><ol><li>完成软件的特性，功能，性能等所需要的 <strong>计算机程序，指令代码</strong>——<strong>程序</strong></li></ol><p>​feature特性： 非功能需求 non-functional：如安全性，兼容性，可移植性，可扩展性等</p><p>​function功能：与非功能需求相对应</p><p>​performance：feature的一部分，但因为很重要所以单拉出来</p><ol start="2"><li><p>使得程序可以充分利用操纵信息所使用的 <strong>数据结构</strong>——<strong>数据</strong></p></li><li><p>描述程序操作使用的硬拷贝和虚拟形式的 <strong>描述性信息</strong>——<strong>文档</strong></p></li></ol><h3 id="2-生命周期：（⭐️）"><a href="#2-生命周期：（⭐️）" class="headerlink" title="2. 生命周期：（⭐️）"></a>2. 生命周期：（⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230226192814338.png" alt="生命周期" style="zoom:67%;" /><ol><li><p>硬件的生命周期——浴缸曲线（早期的infant mortality是由于设计引起问题，当设计问题解决后可以平稳运行，直到硬件损耗，期间替换硬件不影响failure rate）(早期故障多，后期磨损）</p></li><li><p>理想曲线——开发后可以一致运行实际曲线——考虑：1.功能增强的update；2. 功能修改和错误修复modify &amp; bugfixed不断改变后failure rate的突然上升与总体上升: 修改change后导致其他新的问题出现，有”传染性”错误的可扩展性，这是功能调整增强的代价 (错误的扩展性，修复某问题的副作用 )</p></li></ol><h3 id="3-软件的划分：（⭐️⭐️）"><a href="#3-软件的划分：（⭐️⭐️）" class="headerlink" title="3. 软件的划分：（⭐️⭐️）"></a>3. 软件的划分：（⭐️⭐️）</h3><p>​1、系统软件（System Software）</p><p>​2、应用软件（Application Software）</p><p>​3、工程&#x2F;科学软件（Engineering&#x2F;scientific software）</p><p>​4、嵌入式软件（Embedded software）</p><p>​5、产品线软件（Product-line software）</p><p>​6、Web&#x2F;移动App（Web&#x2F;Mobile applications）</p><p>​Mobile app包括：</p><p>​<strong>user interface</strong> 用户界面</p><p>​<strong>interoperability with Web-based resources</strong> 与基于web的资源的互操作性</p><p>​<strong>local processing capabilities</strong> 本地处理能力</p><p>​7、人工智能软件（AI software）</p><h3 id="4-遗留软件的特点：（⭐️⭐️）"><a href="#4-遗留软件的特点：（⭐️⭐️）" class="headerlink" title="4. 遗留软件的特点：（⭐️⭐️）"></a>4. 遗留软件的特点：（⭐️⭐️）</h3><ul><li><p>生命周期长（老不死）</p></li><li><p>业务关键性（涉及ys的底层代码了）</p></li><li><p>质量差：<strong>设计难以扩展，代码令人费解，文档混乱</strong></p></li></ul><h3 id="5-遗留系统演化原因：（⭐️）"><a href="#5-遗留系统演化原因：（⭐️）" class="headerlink" title="5. 遗留系统演化原因：（⭐️）"></a>5. 遗留系统演化原因：（⭐️）</h3><h4 id="AUEA"><a href="#AUEA" class="headerlink" title="AUEA"></a>AUEA</h4><ul><li><p><strong>A</strong> 需要进行适应性调整，满足新的计算环境和计算需求（比如：密码升级到指纹） <strong>new tech adapted</strong></p></li><li><p><strong>U</strong> 升级以实现商业需求 <strong>enhanced implementation</strong></p></li><li><p><strong>E</strong> 扩展使得可以与更多的系统交互，如现代系统或数据库 <strong>extend</strong></p></li><li><p><strong>A</strong> 架构需要重新部署来适应新环境（例如下面以前没有mobile，或部署微服务框架等） <strong>rearchitected</strong></p></li></ul><h3 id="6-云平台架构包括：（⭐️⭐️⭐️）"><a href="#6-云平台架构包括：（⭐️⭐️⭐️）" class="headerlink" title="6. 云平台架构包括：（⭐️⭐️⭐️）"></a>6. 云平台架构包括：（⭐️⭐️⭐️）</h3><ul><li><p><strong>IaaS</strong>层（资源层)</p></li><li><p><strong>虚拟机</strong>（跨IaaS与PaaS）</p></li><li><p><strong>Paas</strong>层（平台层：资源监测；预警；优化决策，<strong>资预优</strong>)</p></li><li><p><strong>SaaS</strong>层 (软件，可视化界面)</p></li></ul><h2 id="Chapter-2-软件工程-Software-Engineering"><a href="#Chapter-2-软件工程-Software-Engineering" class="headerlink" title="Chapter 2 软件工程 Software Engineering"></a><strong>Chapter 2</strong> <strong>软件工程</strong> Software Engineering</h2><h3 id="1-软件工程的定义：（⭐️⭐️⭐️）"><a href="#1-软件工程的定义：（⭐️⭐️⭐️）" class="headerlink" title="1. 软件工程的定义：（⭐️⭐️⭐️）"></a>1. 软件工程的定义：（⭐️⭐️⭐️）</h3><p>（1）将<strong>系统化的</strong>（systematic）、<strong>规范化的</strong>(disciplined)、<strong>可量化的</strong>(quantifiable)方法应用于软件的<strong>开发</strong>、<strong>运行</strong>和<strong>维护</strong></p><p>（2）对（1）方法的研究</p><h3 id="2-软件工程的层次：（⭐️）"><a href="#2-软件工程的层次：（⭐️）" class="headerlink" title="2. 软件工程的层次：（⭐️）"></a>2. 软件工程的层次：（⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230226200336664.png" alt="层次" style="zoom:50%;" /><p>Q 质量: 为什么要有软件工程⇒因为要提高软件的质量，<strong>质量是根基</strong></p><p>P 过程：回答了如何提高质量的问题</p><p>M 方法：方法贯穿于过程中，eg：<strong>UseCase建模，数据库设计方法，架构方法，分析方法，设计方法，测试方法</strong>等多种方法</p><p>T 工具：现在很多方法和技术都工具化了</p><h3 id="3-软件工程的通用过程框架包括：（⭐️⭐️⭐️）"><a href="#3-软件工程的通用过程框架包括：（⭐️⭐️⭐️）" class="headerlink" title="3. 软件工程的通用过程框架包括：（⭐️⭐️⭐️）"></a>3. 软件工程的通用过程框架包括：（⭐️⭐️⭐️）</h3><h4 id="CPMCD"><a href="#CPMCD" class="headerlink" title="CPMCD"></a><strong>CPMCD</strong></h4><ol><li><strong>交流Communication</strong>：需求收集requirement gathering&amp; 需求诱导 elicitation</li><li><strong>计划Planing</strong>：planning是一个大的，阶段的计划（如人员安排等），有很多template</li><li><strong>建模Modeling</strong>：包括分析建模(Analysis modeling)，概要设计(high-level design)， component design 组件设计(detailed design)</li><li><strong>构建Construction</strong>：coding &amp; testing 写代码&amp;测试,测试包括单元测试，系统测试</li><li><strong>部署Deployment</strong>：delivery &amp; maintenance &amp; feedback 交付，维护，反馈</li></ol><p><strong>软件开发过程包括很多迭代，并不是线性顺序的模型，而是循环往复</strong></p><p><strong>Standard Process包含的Activity</strong></p><ol><li><p>requirement elicitation 需求诱导</p></li><li><p>requirement analysis modeling 需求分析建模</p></li><li><p>architecture design 架构设计</p></li><li><p>component design 组件设计</p></li><li><p>coding 写代码</p></li><li><p>unit testing 单元测试</p></li><li><p>integration testing 集成测试</p></li><li><p>system testing 系统测试</p></li><li><p>acceptance testing 验收测试（用户在开发环境下的测试）</p></li><li><p>Release &amp; Delivery， Feedback &amp; Support 发布，交付，反馈，支持</p></li></ol><p><strong>对应CPMCD：</strong></p><p>Communication: 1</p><p>Planning:(umbrella activity)</p><p>Modeling: 2、3、4</p><p>Construction: 5、6、7、8、9 </p><p>Deployment:10</p><h3 id="4-伞形活动（umbrella-activity）包括：（⭐️⭐️⭐️）"><a href="#4-伞形活动（umbrella-activity）包括：（⭐️⭐️⭐️）" class="headerlink" title="4. 伞形活动（umbrella activity）包括：（⭐️⭐️⭐️）"></a>4. 伞形活动（umbrella activity）包括：（⭐️⭐️⭐️）</h3><h4 id="跟风质技测配复工（跟风至极，则配复工）"><a href="#跟风质技测配复工（跟风至极，则配复工）" class="headerlink" title="跟风质技测配复工（跟风至极，则配复工）"></a><strong>跟风质技测配复工</strong>（跟风至极，则配复工）</h4><ul><li><p><strong>软件项目跟踪控制</strong>：根据计划评估进度，采取措施保证计划实施（如：人员计划，发挥成员特长能力，了解人员是tracking，调整人力是control）</p></li><li><p><strong>风险管理</strong>：对可能影响成果或产品质量的风险进行评估(例如，人员流失跳槽风险，新技术、云平台、数据库不熟悉等)</p></li><li><p><strong>软件质量保证</strong>：确定和执行保证软件质量的活动(编程管理，代码规范，需求规约等）</p></li><li><p><strong>技术评审</strong>：评估软件工程 (比如代码Review，需求Review等）</p></li><li><p><strong>测量</strong>：定义和收集过程、项目以及产品的度量（对schedule进行测量，对发现的缺陷进行度量，对人员工作量进行度量等）</p></li><li><p><strong>软件配置管理</strong>：整个软件过程中变更带来的影响（<strong>用Git进行版本控制</strong>）</p></li><li><p><strong>可复用管理</strong>：定义工作产品复用的标准，建立构建复用机制（苹果的复用做的很好，通过标准化可以降低成本）</p></li><li><p><strong>工作产品的准备和生产</strong>：包括生成产品所必须的活动（例如模型、文档、日志、表格和列表）</p></li></ul><h2 id="Chapter-3-软件过程-Software-Process"><a href="#Chapter-3-软件过程-Software-Process" class="headerlink" title="Chapter 3 软件过程 Software Process"></a><strong>Chapter 3</strong> 软件过程 Software Process</h2><h3 id="1-过程模式（-process-patterns）包括：（⭐️⭐️）"><a href="#1-过程模式（-process-patterns）包括：（⭐️⭐️）" class="headerlink" title="1. 过程模式（ process patterns）包括：（⭐️⭐️）"></a>1. 过程模式（ <strong>process patterns</strong>）包括：（⭐️⭐️）</h3><p>混个眼熟</p><p>​1、模式名称（Pattern name）：</p><p>​2、驱动力（Forces）：</p><p>​3、类型：（Type）</p><p>​4、启动上下文（Initial context）</p><p>​5、问题（Problem）</p><p>​6、解决方案（Solution）</p><p>​7、结果上下文（Resulting context）</p><p>​8、相关模式（Related pattern）</p><p>​9、已知应用和实例（Known uses and examples）</p><h3 id="2-过程流分为：（⭐️）"><a href="#2-过程流分为：（⭐️）" class="headerlink" title="2. 过程流分为：（⭐️）"></a><strong>2. 过程流分为：</strong>（⭐️）</h3><h4 id="线代进行"><a href="#线代进行" class="headerlink" title="线代进行"></a><strong>线代进行</strong></h4><ol><li><p>Linear 线性</p></li><li><p>Iterative 迭代</p></li><li><p>Evolutionary 进化&#x2F;演化</p></li><li><p>Parallel 并行</p></li></ol><h3 id="3-任务集的内容：（⭐️）"><a href="#3-任务集的内容：（⭐️）" class="headerlink" title="3. 任务集的内容：（⭐️）"></a>3. 任务集的内容：（⭐️）</h3><ul><li><p>T：work tasks:</p></li><li><p>P：work products: 在work tasks之后形成一个work products</p></li><li><p>Q：quality assurance( QA ) points: 产生work products后要有质量保证</p></li><li><p>M：milestone: 形成里程碑</p></li></ul><h3 id="4-软件改进方法有：（⭐️）"><a href="#4-软件改进方法有：（⭐️）" class="headerlink" title="4. 软件改进方法有：（⭐️）"></a>4. 软件改进方法有：（⭐️）</h3><ul><li><p>用于过程改进的<strong>CMMI</strong>标准评估方法：</p></li><li><p>用于组织内部过程改进的<strong>CMM</strong>评估</p></li><li><p><strong>SPICE</strong></p></li><li><p>软件<strong>ISO</strong></p></li></ul><h3 id="5-软件过程框架中定义了许多activities-actions-和tasks-举例说明并解释它们之间的关系（⭐️⭐️）"><a href="#5-软件过程框架中定义了许多activities-actions-和tasks-举例说明并解释它们之间的关系（⭐️⭐️）" class="headerlink" title="5.软件过程框架中定义了许多activities, actions, 和tasks, 举例说明并解释它们之间的关系（⭐️⭐️）"></a>5.软件过程框架中定义了许多activities, actions, 和tasks, 举例说明并解释它们之间的关系（⭐️⭐️）</h3><ul><li><p><strong>活动activity</strong>主要实现宽泛的⽬标，与应⽤领域，项⽬⼤⼩，结果复杂性或者实施软件⼯程的重要程度没有直接关系</p></li><li><p><strong>动作action</strong>包含了主要⼯作产品⽣产过程中的⼀系列任务</p></li><li><p><strong>任务task</strong>关注⼩⽽明确的⽬标，能够⽣产实际的产品</p></li></ul><p>​         例如testing这个activity,包括actions：单元测试、集成测试、系统测试、验收测试</p><p>​         单元测试这个action包括tasks:计划、⽤例分析、设计测试⽤例、技术评审、运⾏测试⽤例、debug、软件配置管理</p><h2 id="Chapter-4-过程模型-Process-Models"><a href="#Chapter-4-过程模型-Process-Models" class="headerlink" title="Chapter 4 过程模型 Process Models"></a><strong>Chapter 4</strong> 过程模型 Process Models</h2><h3 id="1-简述瀑布模型，简述瀑布模型与V模型的关系：（⭐️⭐️⭐️）"><a href="#1-简述瀑布模型，简述瀑布模型与V模型的关系：（⭐️⭐️⭐️）" class="headerlink" title="1. 简述瀑布模型，简述瀑布模型与V模型的关系：（⭐️⭐️⭐️）"></a>1. 简述瀑布模型，简述瀑布模型与V模型的关系：（⭐️⭐️⭐️）</h3><p>瀑布模型：⼜称为<strong>经典</strong>⽣命周期，它提出了⼀个系统的，顺序的软件开发⽅法，从⽤户需求规格说明开始，通过策划、建模、构建、部署的过程，最终提供完整的软件⽀持。</p><p>瀑布模型的⼀个变体称为V模型</p><img src="https://moe.photo/images/2023/03/06/image-20230301134651997.png" alt="V模型" style="zoom: 44%;" /><p>随着软件团队⼯作沿着V模型左侧步骤向下推进，基本问题需求逐步细化，形成了对问题及解决⽅案的详尽且技术性的描述。⼀旦编码结束，团队沿着V模型右侧的步骤向上推进⼯作，其本质上是执⾏了⼀系列测试，与瀑布模型没有本质区别。</p><h3 id="2-瀑布模型的问题：（⭐️⭐️⭐️）"><a href="#2-瀑布模型的问题：（⭐️⭐️⭐️）" class="headerlink" title="2. 瀑布模型的问题：（⭐️⭐️⭐️）"></a>2. 瀑布模型的问题：（⭐️⭐️⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230225193307697.png" alt="瀑布模型" style="zoom:67%;" /><ol><li><p>实际项目很少遵守瀑布模型的顺序。虽然线性模型可以加入迭代，但它是用直接的方式实现的，可能造成混乱。</p></li><li><p>客户很难描述清楚需求，瀑布模型要求客户明确需求，很难适应项目开始阶段的不确定性。</p></li><li><p>客户必须要有耐心，因为只有项目接近尾声才能得到可执行程序。</p></li><li><p>对于系统中的重大缺陷，如果在可执行程序评审前没有发现，可能造成惨重损失。</p></li><li><p>线性特性在某些项目中会导致阻塞状态。</p></li></ol><h3 id="3-增量过程模型的例子：（⭐️⭐️）"><a href="#3-增量过程模型的例子：（⭐️⭐️）" class="headerlink" title="3. 增量过程模型的例子：（⭐️⭐️）"></a>3. 增量过程模型的例子：（⭐️⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230225193913207.png" alt="增量模型" style="zoom:67%;" /><p>例如，采用增量模型开发文字处理软件，</p><p>在第一个增量中提供基本的文件管理、编辑和文档生成功能；</p><p>在第二个增量中提供更为复杂的编辑和文档生成功能；</p><p>在第三个增量中提供拼写和语法检查功能；</p><p>在第四个增量中提供高级页面排版功能。</p><h3 id="4-增量过程模型的特点：（⭐️⭐️）"><a href="#4-增量过程模型的特点：（⭐️⭐️）" class="headerlink" title="4. 增量过程模型的特点：（⭐️⭐️）"></a>4. 增量过程模型的特点：（⭐️⭐️）</h3><p>每一次增量都生成可发布的产品increment producut，第一个增量形成核心基本产品，后续增量形成完善版本</p><p>每次增量是一个waterfall，一次增量内不主张迭代</p><p>不同增量间可并行开发（比如：第2个做coding时，第3个可做需求建模）——纵轴重合</p><h3 id="5-为什么要用Prototype：（⭐️）"><a href="#5-为什么要用Prototype：（⭐️）" class="headerlink" title="5. 为什么要用Prototype：（⭐️）"></a>5. 为什么要用Prototype：（⭐️）</h3><p>客户定义了一组软件的<strong>一般目标但没有具体需求</strong>时；开发者不知道具体开发细节时，可帮助您和其他利益相关者更好地了解在需求模糊时要构建的内容。</p><h3 id="6-螺旋模型-Spiral-Model的特点：（⭐️⭐️⭐️）"><a href="#6-螺旋模型-Spiral-Model的特点：（⭐️⭐️⭐️）" class="headerlink" title="6. 螺旋模型 Spiral Model的特点：（⭐️⭐️⭐️）"></a>6. 螺旋模型 <strong>Spiral Model的特点：（⭐️⭐️⭐️）</strong></h3><p>一是采用<strong>循环</strong>的方式逐步加深<strong>系统定义和实现</strong>的深度，同时<strong>降低风险</strong>。</p><p>二是确定一系列<strong>里程碑</strong>作为支撑点，确保利益相关者认为系统解决方案可行且令各方满意</p><img src="https://moe.photo/images/2023/03/06/image-20230225194822937.png" alt="螺旋模型" style="zoom:67%;" /><p>适合<strong>大型项目，风险较高的项目，需求不明确的项目(big,risky,unclear)<strong>，将</strong>原型设计的迭代性质与瀑布模型的受控和系统方面相结合</strong>。</p><p>其他process models: 在软件交付时结束；</p><p><strong>spiral model: 在整个软件的生命周期中都适用</strong></p><h2 id="Chapter-5-敏捷开发-Agile-Development"><a href="#Chapter-5-敏捷开发-Agile-Development" class="headerlink" title="Chapter 5 敏捷开发 Agile Development"></a><strong>Chapter 5</strong> 敏捷开发 Agile Development</h2><h3 id="1-敏捷开发强调：（⭐️⭐️⭐️）"><a href="#1-敏捷开发强调：（⭐️⭐️⭐️）" class="headerlink" title="1. 敏捷开发强调：（⭐️⭐️⭐️）"></a>1. 敏捷开发强调：（⭐️⭐️⭐️）</h3><ul><li><p>注重<strong>”客户的满意度</strong>“和”<strong>尽早</strong>提交<strong>可增量</strong>的软件产品“（增量交付，开发过程存在迭代）</p></li><li><p><strong>快速</strong>交付，不看重中间产品</p></li><li><p><strong>小型</strong>，积极的项目团队，协调能力强，看中<strong>团队结构</strong>，协作态度</p></li><li><p>可用<strong>非正式</strong>的方法（e.g. 数据库设计没有写完整的设计文档，中间建模尽量简单）</p></li><li><p><strong>最小</strong>的work product（开发过程简单，会要求尽量减少work product且work product简单，不完全按照template）</p></li><li><p>整体发展<strong>简单</strong>（e.g. 封闭开发）</p></li><li><p>软件工程师和其他项目利益相关者（管理人员，客户，最终用户）在一个敏捷的团队，命运共同体，其中roles和responsibility<strong>随时调整</strong></p></li></ul><h4 id="敏捷开发适应需求变更"><a href="#敏捷开发适应需求变更" class="headerlink" title="敏捷开发适应需求变更"></a><strong>敏捷开发适应需求变更</strong></h4><h3 id="2-Change-Cost图（⭐️）"><a href="#2-Change-Cost图（⭐️）" class="headerlink" title="2. Change Cost图（⭐️）"></a>2. Change Cost图（⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230226132733944.png" alt="change-cost" style="zoom:67%;" /><h4 id="理解敏捷模型的曲线："><a href="#理解敏捷模型的曲线：" class="headerlink" title="理解敏捷模型的曲线："></a>理解敏捷模型的曲线：</h4><p>regression testing回归测试——变更多了后，回归测试成本越来越高，最终翘了上去</p><h3 id="3-敏捷过程原则：（⭐️⭐️⭐️）"><a href="#3-敏捷过程原则：（⭐️⭐️⭐️）" class="headerlink" title="3.敏捷过程原则：（⭐️⭐️⭐️）"></a>3.<strong>敏捷过程原则：（⭐️⭐️⭐️）</strong></h3><ol><li><p><strong>Highest</strong> 最高优先级：通过早期early和连续continuous交付有价值的软件来满足客户</p></li><li><p><strong>Change</strong> 鼓励需求改动，哪怕是开发过程晚期（好的改动可以提升顾客的竞争优势）</p></li><li><p><strong>Frequently</strong> 经常提供work product，最好有短的schedule</p></li><li><p><strong>Together</strong> 甲方和开发者daily紧密合作</p></li><li><p><strong>Motivated</strong> 和有动力的人开发，给他们好的环境和支持，信任他们</p></li><li><p><strong>F-to-F</strong> 面对面讨论，实时解决问题，这是最高效率的</p></li><li><p><strong>WorkingSoftware</strong> 进度的最好指标就是产出的可工作的软件</p></li><li><p><strong>Sustainable</strong> 敏捷过程保持稳定的开发过程，赞助人，开发者和用户应该maintain a constantpace indefinitely (不定期同步跟踪）</p></li><li><p><strong>Excellence</strong> 持续关注追求技术的改进和设计的优化</p></li><li><p><strong>Simplicity</strong> 文档尽量简单</p></li><li><p><strong>Self-organizing</strong> 一个self-organizing的team可以做出最好的架构、需求和设计</p></li><li><p><strong>Reflection</strong> 定期进行回顾</p></li></ol><h3 id="4-描述极限编程（XP）的过程：（⭐️⭐️⭐️）"><a href="#4-描述极限编程（XP）的过程：（⭐️⭐️⭐️）" class="headerlink" title="4. 描述极限编程（XP）的过程：（⭐️⭐️⭐️）"></a>4. 描述极限编程（XP）的过程：（⭐️⭐️⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230226150332179.png" alt="XP" style="zoom: 50%;" /><p><strong>Planning:  策划</strong></p><ol><li>客户设定一系列<strong>stories</strong>，故事的单位是<strong>use case</strong>，被放在<strong>索引卡</strong>上</li><li>客户基于特征或功能的<strong>整体业务价值</strong>为story分配<strong>优先级</strong>，划分依据：</li></ol><p>​         业务上<strong>重要性</strong>(importance)</p><p>​         此功能(story)是否有高<strong>风险</strong>(high risk)</p><p>​         交付时间(<strong>deadline</strong>要求）</p><p>​     3.XP团队<strong>评估</strong>每个故事，并为每个故事分配<strong>开发周</strong>，如果估计故事需要超过<strong>三个</strong>开发周(工作量太大），请客户<strong>拆分</strong>为较小的故事</p><ol start="4"><li><p>一旦<strong>基本承诺</strong>定下，XP团队会将以三种方式之一开发story：</p><p><strong>所有</strong>story将被立即实施（几周之内）</p><p><strong>最高优先级</strong>的story将在计划中提前并首先实施</p><p><strong>最高风险</strong>的story将在计划中提前并首先实施</p></li><li><p>在<strong>第一个</strong>project（software increment）<strong>发布</strong>后，团队计算目前完成的速率(<strong>project velocity</strong>)，即第一个release版本中<strong>部署</strong>user stories数量占总数量的比例。它可以用于评估：</p><p>i. 估计后续发行版本的<strong>发布日期</strong>和开发<strong>进度安排</strong>schedule</p><p>ii. 确定是否有<strong>过分承诺</strong>，如果有，则要修改发布内容或推迟交付日期</p></li><li><p><strong>迭代</strong></p></li></ol><p><strong>Design：设计</strong></p><ol><li><p>鼓励使用<strong>CRC</strong>卡片</p></li><li><p>采用<strong>Spike</strong>解决方案：如果在进行某个功能设计时<strong>遇到困难</strong>，立即建立这部分设计的<strong>可执行原型</strong>并进行<strong>单独测试</strong>。</p></li></ol><p><strong>Coding：编码</strong></p><ol><li>首先开发一系列<strong>unit test</strong>，该测试将测试<strong>当前版本</strong>中包含的<strong>每个</strong>story（软件增量software increment）</li><li>进行Pair Programming <strong>结对编程</strong>，两个人共同为一个故事开发代码</li><li>进行Continuous integration<strong>持续集成</strong>，将pair program结对编程小组的<strong>代码整合</strong>，提供“烟雾测试”环境</li><li>Refactoring <strong>重构</strong>， 让代码规范化、标准化以进行<strong>复用</strong></li></ol><p><strong>Test：测试</strong></p><ol><li><strong>修改</strong>代码时使用<strong>回归测试</strong>策略</li><li>将单元测试组织到<strong>通用测试集</strong>，使得媒体都可以进行集成和确认测试</li><li>进行<strong>验收测试</strong>（客户测试），测试客户可见的整体系统特性和功能</li></ol><h3 id="5-Scrum流程：（⭐️⭐️⭐️）"><a href="#5-Scrum流程：（⭐️⭐️⭐️）" class="headerlink" title="5. Scrum流程：（⭐️⭐️⭐️）"></a>5. Scrum流程：（⭐️⭐️⭐️）</h3><p>scrum是一种敏捷开发过程模型。下面举例描述一下scrum开发全过程：</p><p>1、<strong>首先确定Scrum角色</strong>。</p><p>​<strong>产品负责人</strong>（Product Owner）</p><p>​<strong>Scrum Master</strong>：将team leader和product owner紧密地工作在一起。</p><p>​<strong>团队</strong>（team）：人数一般在5-9个左右</p><p>2、<strong>开发调研</strong>：我们⾸先要确定⼀个<strong>product Backlog</strong>(按优先顺序排列的⼀个产品需求列表)</p><p>3、<strong>工作量估算</strong>：团队根据product backlog做<strong>⼯作量的估算</strong></p><p>4、<strong>Sprint计划会议</strong>：通过Sprint 计划会议, 来从中<strong>挑选</strong>出⼀个Story作为本次迭代完成的⽬标，然后把这个Story进⾏<strong>细化</strong>，形成⼀个Sprint Backlog。团队从<strong>Sprint Backlog</strong>中<strong>挑选</strong>承诺完成的条目，并分解条目成为<strong>工作项</strong>，<strong>评估</strong>工作项工时（小时为单位）。过程中要进⾏<strong>每日站立会议</strong>，汇报昨天完成了什么，今天要做什么，遇到了哪些问题。做到<strong>每日集成</strong>，每天都可以有⼀个成功编译，并且可以演示的版本</p><p>5、<strong>Sprint评审会议</strong>：当⼀个Story完成，业绩就是Sprint backlog完成，这时，要进⾏Sprint 评审会议，团队向 PO 及相关干系人演示产品增量收集意见，为下一个Sprint 做准备</p><p>6、<strong>Sprint回顾会议</strong>：最后就是回顾会议，每个⼈总结并讨论改进，检查哪些方法是值得保留的，哪些是要废弃的。放⼊到下⼀次Sprint的产品需求中</p><h3 id="6-DevOps流程：（⭐️⭐️）"><a href="#6-DevOps流程：（⭐️⭐️）" class="headerlink" title="6. DevOps流程：（⭐️⭐️）"></a>6. DevOps流程：（⭐️⭐️）</h3><h4 id="开测集部监"><a href="#开测集部监" class="headerlink" title="开测集部监"></a>开测集部监</h4><ol><li>Continuous development： 持续开发</li><li>Continuous testing：持续测试</li><li>Continuous integration：持续集成</li><li>Continuous deployment：持续部署</li><li>Continuous monitoring：持续监控</li></ol><h2 id="Chapter-7-软件工程实践原则-Principlesthat-guide-practice"><a href="#Chapter-7-软件工程实践原则-Principlesthat-guide-practice" class="headerlink" title="Chapter 7 软件工程实践原则 Principlesthat guide practice"></a><strong>Chapter 7</strong> <strong>软件工程实践原则 Principlesthat guide practice</strong></h2><h3 id="1-代码进行重构的方法：（⭐️⭐️）"><a href="#1-代码进行重构的方法：（⭐️⭐️）" class="headerlink" title="1. 代码进行重构的方法：（⭐️⭐️）"></a><strong>1. 代码进行重构的方法：（⭐️⭐️）</strong></h3><p>​1、<strong>重命名</strong>：对类，接口，方法，属性等重命名，以使得更易理解。</p><p>​2、<strong>抽取代码</strong>：将方法内一段代码抽取为另一个方法，以使得这段代码可以被其他方法调用。</p><p>​3、<strong>封装字段</strong>：将类的某个字段转换成属性，可以更加合理的控制字段的访问</p><p>​4、<strong>抽取接口</strong>：将类的某些属性、方法抽取组成个接口，将类自动实现该接口。</p><p>​5、提升方法内的<strong>局部变量</strong>变为方法的参数：这主要是是在写代码的过程中会使用到。</p><p>​6、<strong>删除参数</strong>：将方法的一个或多个参数删掉</p><p>​7、<strong>重排参数</strong>：将方法的参数顺序重新排列。</p><h3 id="2-引导过程Process的原则（Principles）：（⭐️⭐️）"><a href="#2-引导过程Process的原则（Principles）：（⭐️⭐️）" class="headerlink" title="2. 引导过程Process的原则（Principles）：（⭐️⭐️）"></a>2. <strong>引导过程</strong>Process的原则（Principles）：（⭐️⭐️）</h3><ol><li><p><strong>Agile</strong> 过程要灵活agile(尽量用敏捷模型开发）</p></li><li><p><strong>Quality</strong> 在每一步产生迭代work product时注重质量</p></li><li><p><strong>Adapt</strong> 做好适配的准备</p></li><li><p>**Team **建立高效团队</p></li><li><p><strong>Communication</strong> 建立沟通和协调coordination机制</p></li><li><p>**Change **管理变更</p></li><li><p><strong>Risk</strong> 风险评估</p></li><li><p><strong>Value</strong> 产品要有价值</p></li></ol><h3 id="3-引导实践Practice的原则（Principles）：（⭐️）"><a href="#3-引导实践Practice的原则（Principles）：（⭐️）" class="headerlink" title="3. 引导实践Practice的原则（Principles）：（⭐️）"></a>3. <strong>引导实践</strong>Practice的原则（Principles）：（⭐️）</h3><ol><li><strong>D&amp;C</strong> 分而治之</li><li>**Abstraction **理解和进行分析抽象</li><li><strong>Consistency</strong> 前后一致尽量做到</li><li>**Transfer **注意信息的转换</li><li><strong>Modularity</strong> 构建表现出有效模块化的软件(类就是模块化)，即类的定义</li><li>**Pattern **寻找模式</li><li><strong>Perspective</strong> 当可能时，从许多不同的角度来看，代表问题及其解决方案</li><li><strong>Maintain</strong> 版本控制，保证人员调整后能接上工作</li></ol><p>​     <strong>引导每个framework activity的原则：CPMCD</strong></p><h2 id="Chapter-8-需求-Requirements"><a href="#Chapter-8-需求-Requirements" class="headerlink" title="Chapter 8 需求 Requirements"></a><strong>Chapter 8</strong> <strong>需求</strong> <strong>Requirements</strong></h2><h3 id="1-Requirement-Engineering（需求工程）的七大步骤：（⭐️⭐️⭐️）"><a href="#1-Requirement-Engineering（需求工程）的七大步骤：（⭐️⭐️⭐️）" class="headerlink" title="1. Requirement Engineering（需求工程）的七大步骤：（⭐️⭐️⭐️）"></a>1. Requirement Engineering（需求工程）的七大步骤：（⭐️⭐️⭐️）</h3><p>IEENSVM</p><ol><li><strong>Inception 初始化</strong>——项目启动阶段</li><li><strong>elicitation 诱导</strong>——需求调研<ul><li>确定商业目标establish business goals（要驱动甲方尽量不保留地表达他们的目标）。</li><li>一旦捕获了目标，就应该建立优先级机制</li><li>形成一套潜在的软件系统架构设计依据</li></ul></li><li><strong>elaboration 阐述</strong>——细化进行建模</li></ol><ul><li><p>进一步明确需求，开发一个细化的需求模型。</p></li><li><p>在这个基础上进行需求分析建模：解析每个用户场景以提取<strong>分析类</strong>，定义每个分析类的属性，并标识每个类所需的服务。识别类之间的关系和协作，并生成各种补充图。</p></li></ul><ol start="4"><li><strong>negotiation 谈判</strong>——需求谈判</li><li><strong>specification 规约</strong>——形成2个规约</li></ol><ul><li><p>需求规约——文字描述，UseCase</p></li><li><p>需求分析规约——文字描述，功能建模，数据建模，行为建模</p></li></ul><ol start="6"><li><strong>validation 验证</strong>——对<strong>规约</strong>进行评审（Formal Technical Review正规技术评审(见指南v1.0)）</li><li><strong>management 管理</strong>——对<strong>需求</strong>进行版本控制和管理</li></ol><p>​    <strong>其产品包括需求规约和需求分析规约</strong></p><h3 id="2-分析模型的组成元素：（⭐️⭐️⭐️）"><a href="#2-分析模型的组成元素：（⭐️⭐️⭐️）" class="headerlink" title="2. 分析模型的组成元素：（⭐️⭐️⭐️）"></a>2. 分析模型的组成元素：（⭐️⭐️⭐️）</h3><ol><li><p>基于场景的元素：use case diagram ， activity diagram (功能建模）</p></li><li><p>基于类的元素：class diagram （数据建模）</p></li><li><p>行为模型： state diagram (sequence diagram)（行为建模）</p></li></ol><h3 id="3-非功能需求包括：（⭐️⭐️）"><a href="#3-非功能需求包括：（⭐️⭐️）" class="headerlink" title="3. 非功能需求包括：（⭐️⭐️）"></a>3. 非功能需求包括：（⭐️⭐️）</h3><p><a href="https://bbs.csdn.net/topics/280033078">非功能需求怎么写-CSDN社区</a></p><p><a href="https://zhuanlan.zhihu.com/p/427254778">软件项目评估：十大常见非功能性需求描述案例整理 - 知乎 (zhihu.com)</a></p><img src="https://moe.photo/images/2023/03/06/image-20230227110713069.png" alt="非功能需求" style="zoom: 67%;" /><h3 id="4-软件需求规约包括：（⭐️）"><a href="#4-软件需求规约包括：（⭐️）" class="headerlink" title="4. 软件需求规约包括：（⭐️）"></a>4. 软件需求规约包括：（⭐️）</h3><p>(a) Environment description and system objectives. 环境描述和系统目标。</p><p>(b) Functionality.功能。</p><p> (c) Non-functional requirements.非功能需求。</p><p> (d) User interface requirements. 用户界面需求。</p><p>(e) System architecture. 系统架构。</p><p>(f) Data requirements. 数据需求。</p><p>(g) Assumptions and dependencies.假设和依赖关系。</p><p> (h) Constraints.限制条件。</p><p> (i) Glossary.术语表。</p><h2 id="Chapter-9-需求建模：基于场景的方法-Requirement-Modeling-Scenario-BasedMethods"><a href="#Chapter-9-需求建模：基于场景的方法-Requirement-Modeling-Scenario-BasedMethods" class="headerlink" title="Chapter 9 需求建模：基于场景的方法 Requirement Modeling:Scenario-BasedMethods"></a><strong>Chapter 9</strong> <strong>需求建模：基于场景的方法 <strong>Requirement Modeling:Scenario-Based</strong>Methods</strong></h2><h3 id="1-需求建模的3个目的：（⭐️）"><a href="#1-需求建模的3个目的：（⭐️）" class="headerlink" title="1.  需求建模的3个目的：（⭐️）"></a>1.  需求建模的3个目的：（⭐️）</h3><ol><li><p>描述<strong>客户需要</strong>什么</p></li><li><p>为<strong>软件设计</strong>奠定基础（架构设计、组件设计）</p></li><li><p><strong>定义</strong>在软件完成后可以被确认的一组<strong>需求</strong></p></li></ol><h3 id="2-举例说明领域建模：（⭐️⭐️⭐️）"><a href="#2-举例说明领域建模：（⭐️⭐️⭐️）" class="headerlink" title="2. 举例说明领域建模：（⭐️⭐️⭐️）"></a>2. 举例说明领域建模：（⭐️⭐️⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230301102524672.png" alt="领域建模" style="zoom: 80%;" /><p><strong>领域分析目的(为什么要Domain Analysis）：创建或提取那些广泛适用的分析类和分析模式，以便于它们可以被复用。</strong></p><ul><li>⽐如我做⼀个进销存系统，⾸先需要学习领域知识</li></ul><p>​从已经开发过的项⽬获取</p><p>​通过⽤户调研获取</p><p>​调研⽬前和将来的需求</p><ul><li>然后进⾏领域分析</li></ul><p>​通过需求规约⾥⾯的⽂字描述，把潜在类提取出来.</p><p>​对于⼀些通⽤的业务类，定义标准的⽅法和属性，然后以后做其他类型的进销存系统可以复⽤</p><ul><li>然后进⾏类的功能建模</li></ul><p>​功能建模要构建activity diagram，反映类的功能逻辑：⽐如有⼀个订单类，客户产⽣订单成功了，就往订单加物品，如果没有成功，就返回尝试产⽣⼀个新订单</p><ul><li>最后要选择⼀种建模语⾔进⾏建模，⽐如UML</li></ul><h3 id="3-软件需求工程分析模型的各个分析模型的内容和作用：（⭐️⭐️⭐️）"><a href="#3-软件需求工程分析模型的各个分析模型的内容和作用：（⭐️⭐️⭐️）" class="headerlink" title="3. 软件需求工程分析模型的各个分析模型的内容和作用：（⭐️⭐️⭐️）"></a>3. 软件需求工程分析模型的各个分析模型的内容和作用：（⭐️⭐️⭐️）</h3><p>关键词：用户、系统、数据、对象、外部</p><img src="https://moe.photo/images/2023/03/06/image-20230227112731549.png" alt="需求工程分析模型" style="zoom: 60%;" /><ul><li><p>基于场景的模型包括用例、user stories和活动图等，描述了<strong>用户</strong>如何与系统<strong>交互</strong>（用例图），以及在使用软件时发生的<strong>活动序列</strong>（活动图）。</p></li><li><p>类模型包括类图、协作图等，为系统将操作的对象建模，描述了对象包含的<strong>属性</strong>、应用于对象的<strong>操作</strong>（方法）、对象之间的<strong>关系</strong>(一些层次结构)，以及类之间发生的<strong>协作</strong>（协作图）。</p></li><li><p>行为模型包括状态图、时序图等，描述了<strong>外部</strong>事件如何改变<strong>系统</strong>或<strong>内部类</strong>的<strong>状态</strong>（状态图）。</p></li><li><p>流模型包括DFSDs等，将系统以<strong>信息流转</strong>的形式表现出来，描述<strong>数据</strong>对象在<strong>流经</strong>各种<strong>系统功能</strong>时如何<strong>转换</strong>。</p></li></ul><h2 id="Chapter-10-类建模-REQUIREMENTS-MODELING-CLASS-BASED-METHODS"><a href="#Chapter-10-类建模-REQUIREMENTS-MODELING-CLASS-BASED-METHODS" class="headerlink" title="Chapter 10 类建模 REQUIREMENTS MODELING: CLASS-BASED METHODS"></a>Chapter 10 类建模 REQUIREMENTS MODELING: CLASS-BASED METHODS</h2><h3 id="1-类图构建方法：（⭐️⭐️）"><a href="#1-类图构建方法：（⭐️⭐️）" class="headerlink" title="1. 类图构建方法：（⭐️⭐️）"></a>1. 类图构建方法：（⭐️⭐️）</h3><ol><li><p>类——找到潜在的类（业务类）</p><p>检查在<em>Chapter 9</em> 中的需求模型中的一部分<em>usage scenarios</em>；以<em>UseCase</em>为单位和依据，对对用例进行语法分析<em>grammatical parse(<em>每个</em>UseCase</em>检查有实义的名词或名词词组等*)*</p></li><li><p>属性和操作——每个UseCase在类定义下来后，初步定义类里面的属性和方法</p></li><li><p>CRC+聚合继承——建立CRC模型，构建聚合和继承关系</p></li><li><p>关联和依赖——构建类与类之间的关联关系、依赖关系</p></li></ol><p>​根据<em>UseCase</em>定义的类之间可能的关联（包括同一个<em>UseCase</em>中的类和不同<em>UseCase</em>中的类）</p><ol start="5"><li>完整类图——构建完整的类图</li></ol><h3 id="2-潜在类的6个特征：（⭐️⭐️⭐️）"><a href="#2-潜在类的6个特征：（⭐️⭐️⭐️）" class="headerlink" title="2. 潜在类的6个特征：（⭐️⭐️⭐️）"></a>2. <strong>潜在类</strong>的6个特征：（⭐️⭐️⭐️）</h3><ol><li><p><strong>Retained Info</strong> 潜在类拥有需要保存在数据库中的信息——持久信息 比如：学生有学号信息等</p></li><li><p><strong>Needed Service</strong> 潜在类中有很多方法服务——服务（方法）比如：学生需要获取成绩</p></li><li><p><strong>Multiple Attributes</strong> 潜在类应该有多个属性→低耦合——多属性 只有一个属性的潜在类往往并入到其他类中</p></li><li><p><strong>Common Attributes</strong> 潜在类有通用属性（泛化，父子关系，基础关系）——通用属性</p></li><li><p><strong>Common Operations</strong> 潜在类有通用方法——通用方法</p></li><li><p><strong>Essential Requirements</strong> 潜在类应该体现基本需求，外部实体、必须的生成和消费信息等几乎总是在需求模型中被定义为类(?)——需求相关</p></li></ol><p>上面的6种特征要全部满足或几乎全部满足。不过提取这些类是主观的过程，之后的评估可能会导致类的增加减少</p><h5 id="如何确定潜在类：对用例描述进行语法扫描，提取名词或名词词组以及动词，合并同义词、近义词后，考察上述六个特征，最终确定潜在类"><a href="#如何确定潜在类：对用例描述进行语法扫描，提取名词或名词词组以及动词，合并同义词、近义词后，考察上述六个特征，最终确定潜在类" class="headerlink" title="如何确定潜在类：对用例描述进行语法扫描，提取名词或名词词组以及动词，合并同义词、近义词后，考察上述六个特征，最终确定潜在类"></a>如何确定潜在类：对用例描述进行语法扫描，提取名词或名词词组以及动词，合并同义词、近义词后，考察上述六个特征，最终确定潜在类</h5><h3 id="3-类关系有：（⭐️⭐️⭐️）"><a href="#3-类关系有：（⭐️⭐️⭐️）" class="headerlink" title="3. 类关系有：（⭐️⭐️⭐️）"></a>3. 类关系有：（⭐️⭐️⭐️）</h3><p><strong>聚合：</strong>汽车与轮胎</p><img src="https://moe.photo/images/2023/03/06/image-20230301163610639.png" alt="聚合" style="zoom: 50%;" /><p><strong>关联</strong>（类之间获取彼此的信息）：老师与学生</p><p><strong>依赖：</strong>现代人与计算机，现代人中的方法用到了计算机这个类</p><p><strong>泛化：</strong>鸟和动物</p><p><strong>组合：</strong>公司和部门</p><img src="https://moe.photo/images/2023/03/06/image-20230301163641648.png" alt="组合" style="zoom:50%;" /><p>组合与聚合：</p><p>聚合 部分可以离开整体存在</p><p>组合 部分不能离开整体存在</p><h2 id="Chapter-11-行为-模式和Web-x2F-Mobile应用-Behavior-Pattern-and-Web-x2F-Mobile-App"><a href="#Chapter-11-行为-模式和Web-x2F-Mobile应用-Behavior-Pattern-and-Web-x2F-Mobile-App" class="headerlink" title="Chapter 11 行为,模式和Web&#x2F;Mobile应用 Behavior, Pattern and Web&#x2F;Mobile App"></a><strong>Chapter 11</strong> 行为,模式和Web&#x2F;Mobile应用 Behavior, Pattern and Web&#x2F;Mobile App</h2><h3 id="1-行为建模的基本步骤：（⭐️）"><a href="#1-行为建模的基本步骤：（⭐️）" class="headerlink" title="1.  行为建模的基本步骤：（⭐️）"></a>1.  行为建模的基本步骤：（⭐️）</h3><ul><li><p>评估所有用例以完全理解系统内交互的顺序</p></li><li><p>识别驱动交互序列的事件，并理解这些事件如何与特定对象关联</p></li><li><p>为每个用例创建一个序列</p></li><li><p>为系统或类构建状态图</p></li><li><p>回顾行为模型以验证准确性和一致性</p></li></ul><h3 id="2-举例说明Web-x2F-Mobile应用中交互建模、功能建模、内容建模、导航建模之间的关系：（⭐️⭐️⭐️）"><a href="#2-举例说明Web-x2F-Mobile应用中交互建模、功能建模、内容建模、导航建模之间的关系：（⭐️⭐️⭐️）" class="headerlink" title="2. 举例说明Web&#x2F;Mobile应用中交互建模、功能建模、内容建模、导航建模之间的关系：（⭐️⭐️⭐️）"></a>2. 举例说明Web&#x2F;Mobile应用中交互建模、功能建模、内容建模、导航建模之间的关系：（⭐️⭐️⭐️）</h3><ul><li><p><strong>内容建模</strong>，借助<strong>数据树</strong>确定界面中的<strong>内容对象</strong>，相应的<strong>控件布局</strong>，是界面设计的基础</p></li><li><p><strong>交互建模</strong>，以界面交互为导向，用界面驱动<strong>活动图</strong>的功能逻辑，借助活动图，利用内容模型构建的界面进行交互</p></li><li><p><strong>功能建模</strong>，借助<strong>活动图</strong>，在交互模型的基础上，为完成<strong>特定功能</strong>的界面进行<strong>细化</strong>，将用例的活动图改为界面来驱动</p></li><li><p><strong>导航建模</strong>，即构建前端界面的导航，它把内容建模中的<strong>内容对象</strong>放在⼀起，形成⼀个<strong>内容对象流</strong>，完成特定功能</p></li></ul><h2 id="Chapter-12-设计概念-Design-Concepts"><a href="#Chapter-12-设计概念-Design-Concepts" class="headerlink" title="Chapter 12 设计概念 Design Concepts"></a><strong>Chapter 12</strong> <strong>设计概念</strong> <strong>Design Concepts</strong></h2><h3 id="1-举例说明软件建模活动从需求模型向设计模型的转换过程：（⭐️⭐️⭐️）"><a href="#1-举例说明软件建模活动从需求模型向设计模型的转换过程：（⭐️⭐️⭐️）" class="headerlink" title="1. 举例说明软件建模活动从需求模型向设计模型的转换过程：（⭐️⭐️⭐️）"></a>1. 举例说明软件建模活动从需求模型向设计模型的转换过程：（⭐️⭐️⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230227160838875.png" alt="转换过程" style="zoom: 50%;" /><ol><li><strong>数据设计、类设计</strong></li></ol><p>将类模型转化为<strong>设计类</strong>以及其他要求实现的<strong>数据结构</strong>，<strong><em>CRC</em>中的对象与关系</strong>、<strong>类属性</strong>以及<strong>其他表示法</strong>描述的数据内容为数据设计活动提供了基础。部分类设计可能与软件体系结构的设计一起进行。在设计每个软件组件时，会出现更详细的类设计。</p><ol start="2"><li><strong>体系结构设计</strong></li></ol><p>定义软件的主要结构化元素、结构风格和模式之间的关系，表示一个基于计算机系统的框架，它以类图和类之间协作关系作为重要依据，设计时基于<strong>类图和CRC</strong>片，把功能相关的类构建为一个<strong>子系统</strong>，并明确子系统间的<strong>通信方式</strong>，进而增加<strong>接口类</strong>。</p><ol start="3"><li><strong>接口设计</strong></li></ol><p>描述软件和<strong>使用人员</strong>之间、软件和<strong>协作系统</strong>之间如何通信。因此，场景和行为建模（用例图、状态图）提供了接口设计所需的许多信息，如参考用例图中用例与用户的<strong>交互</strong>、状态图中类<strong>状态切换</strong>时需要传递的信息。</p><ol start="4"><li><strong>构件级设计</strong></li></ol><p>将软件体系机构设计的<strong>结构化元素</strong>变换为对软件构件的<strong>过程性描述</strong>。从基于类的模型和行为模型（时序图）中获得的信息可以作为组件设计的基础，如从类图中获取<strong>类内方法</strong>，以及从时序图中获取某类<strong>调用其他类的方法</strong>。</p><h3 id="2-软件质量属性包括：（⭐️⭐️）"><a href="#2-软件质量属性包括：（⭐️⭐️）" class="headerlink" title="2. 软件质量属性包括：（⭐️⭐️）"></a>2. 软件质量属性包括：（⭐️⭐️）</h3><p>Furps</p><ul><li><p>Functionality <strong>功能性</strong>，评估程序的特性与功能、功能通用性generality与系统安全性security</p></li><li><p>Usability <strong>可用性</strong>，评估整体美观性aesthetics、一致性consistency和文档等使用体验</p></li><li><p>Reliability <strong>可靠性</strong>，评估通过测量失败的频率和严重程度,输出结果的准确性accuracy,程序的可预测性predictability</p></li><li><p>Performance <strong>性能</strong>，衡量处理速度、响应时间、资源消耗,吞吐量和效率</p></li><li><p>Supportability <strong>可支持性</strong>，可维护性maintainability，包括了可扩展性、适应性和可服务性，还有可测试性testability，兼容性compatibility，可配置性configurability</p></li></ul><h3 id="3-模块化和软件成本：（⭐️）"><a href="#3-模块化和软件成本：（⭐️）" class="headerlink" title="3. 模块化和软件成本：（⭐️）"></a>3. 模块化和软件成本：（⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230227162317431.png" alt="软件成本" style="zoom:50%;" /><p>随着模块数量的增多，用于integrate的开销越大，而每个模块开发的成本平摊越少，两者加起来类似一个二次函数，这个二次函数有个最优区间，叫最小开销区间（M）</p><p>Pi：某功能</p><p>C：复杂度</p><p>E：工作量</p><p>一般对任务$P1$，$P2$，如果$C(P1)&gt;C(P2)$ ，那么$E(P1)&gt;E(P2)$</p><p>另外有:</p><p>$E(P1+P2)&gt;E(P1)+E(P2)$</p><p>$C(P1+P2)&gt;C(P1)+C(P2)$</p><p>分而治之在这里体现，合在一起做工作量更大，分而治之可以节约成本</p><h3 id="4-设计类的种类：（⭐️⭐️⭐️）"><a href="#4-设计类的种类：（⭐️⭐️⭐️）" class="headerlink" title="4. 设计类的种类：（⭐️⭐️⭐️）"></a>4. 设计类的种类：（⭐️⭐️⭐️）</h3><ol><li><p>User Interface classes 用户界面类（sequence diagram &amp; use case diagram)</p></li><li><p>Business domain classes 业务类（由分析类直接转过来，基本是一对一，可能有优化比如一个分析类分成2个类等）</p></li><li><p>Process classes&#x2F;Control classes 控制类（往往没有属性，只有方法）对系统的可维护性很重要</p></li><li><p>Persistent classes 持久类（用于数据持久化，比如被Hibernate持久化到数据库中的类，持久化类的实例对象将保存在数据库或文件中）</p></li><li><p>System classes 系统类（如Java的主类有main()方法）</p></li></ol><h3 id="5-设计类的四个指标：（⭐️⭐️）"><a href="#5-设计类的四个指标：（⭐️⭐️）" class="headerlink" title="5. 设计类的四个指标：（⭐️⭐️）"></a>5. 设计类的四个指标：（⭐️⭐️）</h3><ol><li><p>Complete and Sufficient 完整充分（属性方法的完整封装encapsulation）封装良好</p></li><li><p>Primitiveness 原始性（同样的功能和属性不能在2个或多个类中出现） 不重复，每个属性方法都是原始的</p></li><li><p>High Cohesion 高内聚（属性和方法<strong>与类本身相关</strong>）</p></li><li><p>Low Coupling 低耦合（<strong>交互接口</strong>要简单）</p></li></ol><p>​接口类的存在就是为了低耦合；一个类更多应该访问邻界类，尽量少访问其他package或subsystem；子系统中的一个类不需要知道其他类太多信息，最好通过内部接口或外部接口这些控制接口类去访问得到</p><h2 id="Chapter-13-概要设计-Architectural-Design"><a href="#Chapter-13-概要设计-Architectural-Design" class="headerlink" title="Chapter 13 概要设计 Architectural Design"></a><strong>Chapter 13</strong> <strong>概要设计</strong> Architectural Design</h2><h3 id="1-体系结构典中典的例子：（⭐️⭐️⭐️）"><a href="#1-体系结构典中典的例子：（⭐️⭐️⭐️）" class="headerlink" title="1. 体系结构典中典的例子：（⭐️⭐️⭐️）"></a>1. 体系结构典中典的例子：（⭐️⭐️⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230227172631963.png" alt="体系结构" style="zoom: 50%;" /><h3 id="2-体系结构设计包括：（⭐️⭐️⭐️）"><a href="#2-体系结构设计包括：（⭐️⭐️⭐️）" class="headerlink" title="2. 体系结构设计包括：（⭐️⭐️⭐️）"></a>2. 体系结构设计包括：（⭐️⭐️⭐️）</h3><ol><li><p>软件架构设计</p></li><li><p>数据&#x2F;数据库设计（以类图为依据，有时涉及数据字典设计，和接口紧密相关）</p></li><li><p>接口设计（内部接口（类内方法互相调用) ，类间，子系统间方法调用，外部接口，用户接口）</p></li></ol><h3 id="3-系统上下文的建立：（⭐️⭐️⭐️）"><a href="#3-系统上下文的建立：（⭐️⭐️⭐️）" class="headerlink" title="3.系统上下文的建立：（⭐️⭐️⭐️）"></a>3.<strong>系统上下文的建立</strong>：（⭐️⭐️⭐️）</h3><img src="https://moe.photo/images/2023/03/06/image-20230227215523598.png" alt="ACD" style="zoom:50%;" /><p>在体系结构设计层，ACD图对软件与其外围实体的交互方式进行建模。</p><ul><li><p>上级系统：这些系统<strong>把</strong>目标系统作为某些高层处理方案的一部分。</p></li><li><p>下级系统：这些系统<strong>被</strong>目标系统使用，并为完成目标系统的功能提供必要的数据和处理。</p></li><li><p>同级系统：这些系统在<strong>对等</strong>的基础上<strong>相互作用</strong>（即信息或者由同级系统和目标系统产生，或者被同级系统或目标系统使用）</p></li><li><p>参与者：通过<strong>产生和消耗</strong>必要的信息，实现与目标系统<strong>交互</strong>的<strong>实体</strong></p><p><img src="https://moe.photo/images/2023/03/06/image-20230301235838116.png" alt="图书馆系统上下文"></p></li></ul><h3 id="4-举例说明ACD在体系结构设计中的作用：（⭐️⭐️）"><a href="#4-举例说明ACD在体系结构设计中的作用：（⭐️⭐️）" class="headerlink" title="4. 举例说明ACD在体系结构设计中的作用：（⭐️⭐️）"></a>4. 举例说明ACD在体系结构设计中的作用：（⭐️⭐️）</h3><ol><li><p>提供系统需要如何与其他企业<strong>交互</strong>的<strong>组织视图</strong>，描述软件所在的<strong>业务生态系统</strong>。</p></li><li><p><strong>标识</strong>外部系统。</p></li><li><p>提供了业务<strong>上下文的分解</strong>，并提供了对业务上下文信息的<strong>可跟踪性</strong>。</p></li><li><p>帮助标识构建<strong>完整的解决方案</strong>所需的一些主要体系结构<strong>构件</strong>。</p></li><li><p><strong>信息流</strong>还表示对体系结构而言非常重要的活动，这些活动可以回溯到<strong>业务流程模型</strong>，而后者是表示<strong>系统需求</strong>的一个主要部分。</p></li></ol><h2 id="Chapter-14-详细设计-Component-LevelDesign"><a href="#Chapter-14-详细设计-Component-LevelDesign" class="headerlink" title="Chapter 14 详细设计 Component-LevelDesign"></a><strong>Chapter 14</strong> <strong>详细设计</strong> Component-Level<strong>Design</strong></h2><h3 id="1-实施构件级设计的方法：（⭐️）"><a href="#1-实施构件级设计的方法：（⭐️）" class="headerlink" title="1. 实施构件级设计的方法：（⭐️）"></a>1. 实施构件级设计的方法：（⭐️）</h3><ol><li><strong>标识</strong>所有问题域对应的设计类</li><li><strong>确定</strong>所有与<strong>基础设施</strong>相对应的设计类</li><li><strong>细化</strong>不需要作为<strong>复用</strong>构件的设计类</li></ol><p>​a. 在类或构件协作时说明消息细节</p><p>​b. 为每个构件确定适当接口</p><p>​c. 细化属性，并根据定义实现属性所需要的数据类型和结构</p><p>​d. 详细描述每个操作的处理流</p><ol start="4"><li>说明<strong>持久数据源</strong>并确定管理数据源所需要的类</li><li>开发并且细化类或构件的<strong>行为表示</strong></li><li>细化<strong>部署图</strong></li><li>考虑构件级<strong>设计表示</strong>，并且时刻考虑其他<strong>可选方案</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
      <tag>工程管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客（速通版）</title>
    <link href="/2023/02/04/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%80%9F%E9%80%9A%E7%89%88%EF%BC%89/"/>
    <url>/2023/02/04/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%80%9F%E9%80%9A%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>由于本人之前学习前端时已经配置过了node相关环境，因此本次搭建异常顺利，参考链接：<a href="http://t.csdn.cn/OVpth">http://t.csdn.cn/OVpth</a></p><p>接下来我将提到文章中的一些注意要点。</p><h2 id="一-关于Github-Page"><a href="#一-关于Github-Page" class="headerlink" title="一.关于Github Page"></a>一.关于Github Page</h2><h3 id="创建-Yourname-github-io-仓库"><a href="#创建-Yourname-github-io-仓库" class="headerlink" title="创建 Yourname.github.io 仓库"></a>创建 Yourname.github.io 仓库</h3><p><strong>填写仓库名的格式：Yourname.github.io。</strong><br>Yourname 需要和 xxx.github.com 保持一致，否则访问地址会是：<a href="https://tom.github.com/tom.github.io">https://tom.github.com/tom.github.io</a> ，无法通过 Yourname.github.io 域名记性访问。<br>例如： github网址：tom.github.com ，那么新建的仓库名是：tom.github.io。</p><p><img src="https://img-blog.csdnimg.cn/3eb7a2f57ec346edbdc65caf996f7b52.png" alt="img"></p><h3 id="进入-setting-下的-pages-选项"><a href="#进入-setting-下的-pages-选项" class="headerlink" title="进入 setting 下的 pages 选项"></a>进入 setting 下的 pages 选项</h3><p>在github pages页面，source 选择Deploy from a branch，Branch 根据仓库的分支名来确定，这里是main 的 &#x2F; 根目录下。</p><p><img src="https://img-blog.csdnimg.cn/2bd60412968742e19bf32399d19a592f.png" alt="img"></p><h2 id="二-配置-Hexo"><a href="#二-配置-Hexo" class="headerlink" title="二.配置 Hexo"></a>二.配置 Hexo</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p><strong>全局安装（小白推荐，cmd中可直接使用hexo init）</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p><strong>局部安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo  <span class="hljs-comment"># npm 安装 hexo`</span><br><br>npx hexo &lt;<span class="hljs-built_in">command</span>&gt;  <span class="hljs-comment"># npm5.2版以后可用，npx init myhexo ；npx 将 hexo 下载到一个临时目录，再次执行 重新下载 hexo。`</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.profile  <span class="hljs-comment"># 记得将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo &lt;command&gt;`</span><br></code></pre></td></tr></table></figure><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a><strong>依赖配置</strong></h3><p>新建hexo文件夹，并将其放到博客目录里，即让其成为你的xxx.github.io文件夹的一级子文件夹</p><p>执行以下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd hexo<br> <br>hexo init <span class="hljs-regexp">//</span>Hexo 即会自动在目标文件夹建立网站所需要的所有文件。<br> <br>npm install <span class="hljs-regexp">//</span>安装依赖包<br></code></pre></td></tr></table></figure><h3 id="查看Hexo服务"><a href="#查看Hexo服务" class="headerlink" title="查看Hexo服务"></a>查看Hexo服务</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span>  # 或者 hexo g ；生成静态文件<br> <br>hexo server  # 启动本地http服务 浏览器输入：http:<span class="hljs-comment">//localhost:4000</span><br></code></pre></td></tr></table></figure><p>server启动正常即说明搭建成功。</p><h2 id="三-配置Fluid-主题"><a href="#三-配置Fluid-主题" class="headerlink" title="三.配置Fluid 主题"></a>三.配置Fluid 主题</h2><h3 id="安装Fluid"><a href="#安装Fluid" class="headerlink" title="安装Fluid"></a>安装Fluid</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><p>具体内容可见参考链接。</p><h3 id="修改基础配置"><a href="#修改基础配置" class="headerlink" title="修改基础配置"></a>修改基础配置</h3><p>在 hexo 目录下找到并修改 _config.yml 文件：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br> <br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h2 id="四-尝试hexo基本操作"><a href="#四-尝试hexo基本操作" class="headerlink" title="四.尝试hexo基本操作"></a>四.尝试hexo基本操作</h2><h3 id="尝试新建博客中的-关于-页面"><a href="#尝试新建博客中的-关于-页面" class="headerlink" title="尝试新建博客中的 关于  页面"></a>尝试新建博客中的 <em>关于</em>  页面</h3><p>在hexo 目录下执行：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><p>建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，这里添加 layout 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-meta"> </span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br> <br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br> <br><span class="hljs-meta">---</span><br><span class="hljs-meta"> </span><br><span class="hljs-meta"></span><br><span class="hljs-meta"> </span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><h3 id="发布（deploy）"><a href="#发布（deploy）" class="headerlink" title="发布（deploy）"></a>发布（deploy）</h3><p> <strong>修改 hexo 目录下的_config.yml 文件：</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/Yourname/Yourname.github.io.git</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><p><strong>安装发布插件：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-deployer-git –save<br></code></pre></td></tr></table></figure><p><strong>在 hexo 目录下 ，CMD中输入</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean <span class="hljs-comment">//清除缓存文件 db.json 和已生成的静态文件 public</span><br> <br>hexo <span class="hljs-keyword">generate</span> <span class="hljs-comment">//生成网站静态文件到默认设置的 public 文件夹</span><br> <br>hexo deploy <span class="hljs-comment">//自动生成网站静态文件，并部署到设定的仓库。</span><br></code></pre></td></tr></table></figure><p>过程中会提示你输入账号名和密码，Username是你的Github账号名称，而不是邮箱；Password就是你的Github的密码。</p><p>此时 在浏览器中输入 Yourname.github.io 即可访问创建好的站点了。</p><p><strong>尝试新建文章，在 hexo 目录下执行：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;my-article-title&quot;</span><br></code></pre></td></tr></table></figure><p>会在 &#x2F;source&#x2F;_posts 中新建一个以 my-article-title.md 为名字的<a href="https://so.csdn.net/so/search?q=markdown&spm=1001.2101.3001.7020">markdown</a>文件，编辑这个文件之后再一次部署，过几分钟就可以看到博客的更新了。</p><p>部署命令:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">hexo deploy</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>fluid</tag>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
